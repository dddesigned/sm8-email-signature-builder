<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Email Signature Builder</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; height: 100vh; display: flex; flex-direction: column; background: #f8f9fa; }
        .header { padding: 10px 15px; background: #045E8C; color: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center; }
        .header-left { display: flex; align-items: center; gap: 12px; }
        .header-logo { height: 50px; width: 50px; object-fit: contain; }
        .header h1 { font-size: 22px; color: white; font-weight: 600; letter-spacing: -0.5px; }
        .version { font-size: 13px; color: rgba(255,255,255,0.9); font-weight: 500; background: rgba(255,255,255,0.2); padding: 4px 4px 4px 12px; border-radius: 20px; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; align-self: center; gap: 6px; }
        .version:hover { background: rgba(255,255,255,0.3); }
        .version-icon { width: 20px; height: 20px; stroke: rgba(255,255,255,0.9); fill: none; }
        .container { display: flex; flex: 1; overflow: hidden; }
        .left-panel { width: 520px; border-right: none; display: flex; flex-direction: column; background: white; box-shadow: 2px 0 10px rgba(0,0,0,0.05); }
        .right-panel { flex: 1; display: flex; flex-direction: column; }
        .controls { padding: 10px 15px; background: white; border-bottom: 1px solid #e9ecef; display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: nowrap; }
        .global-controls-wrapper { display: flex; align-items: center; gap: 20px; }
        .controls-left { display: flex; align-items: center; gap: 12px; padding-right: 10px; border-right: 1px solid #e9ecef; }
        .controls label { font-size: 13px; font-weight: 600; color: #495057; display: flex; align-items: center; white-space: nowrap; }
        .spacing-icon { width: 24px; height: 24px; margin-right: 5px; }
        .font-size-icon { width: 20px; height: 20px; margin-right: 5px; }
        .global-font-wrapper { display: flex; align-items: center; margin-right: 0; }
        .global-font-select { height: 28px; border: 1px solid #dee2e6; border-radius: 6px; background: white; cursor: pointer; font-size: 11px; padding: 0 8px; color: #495057; font-family: monospace; transition: all 0.2s; }
        .global-font-select:focus { outline: none; border-color: #045E8C; box-shadow: 0 0 0 3px rgba(4,94,140,0.1); }
        .spacing-wrapper { position: relative; display: inline-block; margin-left: 0; }
        .spacing-wrapper::after { content: 'px'; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 11px; color: #6c757d; pointer-events: none; transition: opacity 0.2s; }
        .spacing-wrapper:hover::after, .spacing-wrapper:focus-within::after { opacity: 0; }
        .controls input { padding: 6px 10px; border: 1px solid #dee2e6; border-radius: 6px; width: 60px; font-size: 13px; transition: all 0.2s; }
        .controls input:focus { outline: none; border-color: #045E8C; box-shadow: 0 0 0 3px rgba(4,94,140,0.1); }
        .controls button { padding: 7px 13px; background: #045E8C; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; white-space: nowrap; }
        .controls button:hover { background: #034a6f; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(4,94,140,0.3); }
        .controls button:active { transform: translateY(0); }
        .items-container { flex: 1; overflow-y: auto; padding: 15px; background: white; }
        .zone { margin-bottom: 25px; min-height: 60px; }
        .zone-header { font-size: 11px; font-weight: 700; color: #6c757d; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .item { padding: 7px; margin: 5px 0; background: white; border: 2px solid #e9ecef; border-radius: 12px; cursor: move; display: flex; justify-content: space-between; align-items: center; gap: 10px; transition: all 0.2s; }
        .item:hover { border-color: #dee2e6; box-shadow: 0 3px 12px rgba(4,94,140,0.15); }
        .item.dragging { opacity: 0.6; transform: scale(0.98); }
        .item.drag-over { border-top: 3px solid #045E8C; box-shadow: 0 4px 12px rgba(4,94,140,0.2); }
        .item.spacer { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-color: #dee2e6; border-radius: 14px; min-height: 48px; }
        .item.static-text { background: linear-gradient(135deg, #fff9e6 0%, #fff3cd 100%); border-color: #ffe69c; border-radius: 14px; }
        .item-left { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
        .item-label { font-size: 14px; flex: 1; min-width: 0; color: #212529; font-weight: 500; }
        .item-label input { border: none; background: transparent; font-size: 14px; width: 100%; padding: 2px 6px; border-radius: 4px; transition: all 0.2s; }
        .item-label input:focus { outline: none; background: rgba(4,94,140,0.08); box-shadow: 0 0 0 2px rgba(4,94,140,0.15); }
        .prefix-btn { width: 48px; height: 28px; padding: 0; font-size: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; color: #495057; display: flex; align-items: center; justify-content: center; white-space: nowrap; }
        .prefix-btn.active { background: #045E8C; color: white; border-color: #045E8C; }
        .prefix-btn:hover { background: #e9ecef; border-color: #ced4da; }
        .prefix-btn.active:hover { background: #034a6f; border-color: #034a6f; }
        .item-controls { display: flex; gap: 0; align-items: center; }
        .format-control-bar { display: flex; gap: 0; border: 1px solid #dee2e6; border-radius: 6px; overflow: hidden; }
        .font-size-select { height: 28px; border: none; border-right: 1px solid #dee2e6; background: white; cursor: pointer; font-size: 11px; padding: 0 4px; font-family: monospace; transition: color 0.2s; }
        .font-size-select.manual { color: #045E8C; font-weight: 600; }
        .font-size-select.global { color: #6c757d; }
        .font-size-select:focus { outline: none; background: #f8f9fa; }
        .format-buttons { display: flex; gap: 0; }
        .format-btn { width: 28px; height: 28px; border: none; border-right: 1px solid #dee2e6; background: white; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.15s; color: #495057; }
        .format-btn.active { background: #045E8C; color: white; }
        .format-btn:hover { background: #f8f9fa; }
        .format-btn.active:hover { background: #034a6f; }
        .color-input { width: 32px; height: 28px; border: none; border-left: 1px solid #dee2e6; cursor: pointer; transition: all 0.2s; }
        .color-input:hover { background: #f8f9fa; }
        .hex-input { width: 60px; height: 28px; border: none; border-left: 1px solid #dee2e6; padding: 0 6px; font-size: 11px; font-family: monospace; text-transform: uppercase; }
        .hex-input:focus { outline: none; background: #f8f9fa; }
        .spacer-input { width: 60px; padding: 5px 8px; border: 1px solid #dee2e6; border-radius: 6px; font-size: 13px; transition: all 0.2s; }
        .spacer-input:focus { outline: none; border-color: #045E8C; box-shadow: 0 0 0 3px rgba(4,94,140,0.1); }
        .spacer-controls { display: flex; gap: 8px; align-items: center; }
        .spacer-height-group { display: flex; align-items: center; gap: 2px; position: relative; }
        .spacer-height-group::after { content: 'px'; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 11px; color: #6c757d; pointer-events: none; transition: opacity 0.2s; }
        .spacer-height-group:hover::after, .spacer-height-group:focus-within::after { opacity: 0; }
        .line-toggle-wrapper { display: flex; align-items: center; gap: 6px; }
        .line-toggle-label { font-size: 11px; color: #6c757d; font-weight: 600; }
        .line-toggle { position: relative; width: 36px; height: 20px; background: #dee2e6; border-radius: 10px; cursor: pointer; transition: all 0.2s; border: none; }
        .line-toggle.active { background: #045E8C; }
        .line-toggle::after { content: ''; position: absolute; width: 16px; height: 16px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .line-toggle.active::after { left: 18px; }
        .line-controls { display: flex; gap: 8px; align-items: center; }
        .line-control-group { display: flex; align-items: center; gap: 2px; }
        .line-control-label { font-size: 11px; color: #6c757d; font-weight: 600; }
        .control-icon { width: 16px; height: 16px; stroke: #6c757d; flex-shrink: 0; }
        .line-input { height: 28px; border: 1px solid #dee2e6; border-radius: 6px; background: white; cursor: pointer; font-size: 11px; padding: 0 8px; color: #495057; font-family: monospace; transition: all 0.2s; }
        .line-input:focus { outline: none; border-color: #045E8C; background: #f8f9fa; }
        .line-color-bar { display: flex; gap: 0; border: 1px solid #dee2e6; border-radius: 6px; overflow: hidden; }
        .line-color-input { width: 32px; height: 28px; border: none; cursor: pointer; transition: all 0.2s; }
        .line-color-input:hover { background: #f8f9fa; }
        .line-hex-input { width: 60px; height: 28px; border: none; border-left: 1px solid #dee2e6; padding: 0 6px; font-size: 11px; font-family: monospace; text-transform: uppercase; }
        .line-hex-input:focus { outline: none; background: #f8f9fa; }
        .preview-container { flex: 1; overflow-y: auto; padding: 40px; background: #f8f9fa; display: flex; flex-direction: column; }
        .preview-mode-toggle { display: flex; justify-content: center; margin-bottom: 20px; }
        .mode-btn-group { display: inline-flex; background: white; border-radius: 8px; padding: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 1px solid #dee2e6; }
        .mode-btn { padding: 8px 24px; border: none; background: transparent; cursor: pointer; font-size: 13px; font-weight: 600; color: #6c757d; border-radius: 6px; transition: all 0.2s; }
        .mode-btn.active { background: #045E8C; color: white; box-shadow: 0 2px 4px rgba(4,94,140,0.2); }
        .mode-btn:hover:not(.active) { background: #f8f9fa; color: #495057; }
        .preview-wrapper { max-width: 650px; margin: 0 auto; background: white; padding: 40px; border: none; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .email-placeholder { padding: 0 0 30px 0; margin-bottom: 30px; color: #6c757d; font-size: 14px; line-height: 1.6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .email-placeholder p { margin: 0 0 12px 0; }
        .email-placeholder p:last-child { margin-bottom: 0; }
        .copy-btn { padding: 8px 16px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; box-shadow: 0 2px 6px rgba(16,185,129,0.3); min-width: 130px; }
        .copy-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(16,185,129,0.4); }
        .copy-btn:active { transform: translateY(0); }
        .paste-btn { padding: 8px 16px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); min-width: 145px; }
        .paste-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(59,130,246,0.4); }
        .paste-btn:active { transform: translateY(0); }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
        .modal.show { display: flex; }
        .modal-content { background: white; padding: 25px; border-radius: 12px; width: 420px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); }
        .modal-header { font-size: 18px; font-weight: 600; margin-bottom: 18px; color: #212529; }
        .modal-body input { width: 100%; padding: 10px 12px; border: 1px solid #dee2e6; border-radius: 8px; font-size: 14px; transition: all 0.2s; }
        .modal-body input:focus { outline: none; border-color: #045E8C; box-shadow: 0 0 0 3px rgba(4,94,140,0.1); }
        .modal-body textarea { width: 100%; min-height: 200px; padding: 12px; border: 1px solid #dee2e6; border-radius: 8px; font-size: 13px; font-family: monospace; transition: all 0.2s; resize: vertical; }
        .modal-body textarea:focus { outline: none; border-color: #045E8C; box-shadow: 0 0 0 3px rgba(4,94,140,0.1); }
        .paste-modal-content { width: 600px; }
        .changelog-modal-content { width: 700px; max-height: 80vh; display: flex; flex-direction: column; padding: 25px 0 25px 25px; }
        .changelog-modal-content .modal-body { flex: 1; overflow-y: auto; margin-bottom: 20px; padding-right: 25px; margin-right: 0; }
        .changelog-modal-content .modal-footer { flex-shrink: 0; margin-top: 0; padding-top: 20px; padding-right: 25px; border-top: 1px solid #e9ecef; }
        .changelog-header { font-size: 24px; font-weight: 700; margin-bottom: 20px; color: #045E8C; flex-shrink: 0; padding-right: 25px; }
        .changelog-version { margin-bottom: 25px; }
        .changelog-version-title { font-size: 18px; font-weight: 600; color: #212529; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef; }
        .changelog-list { list-style: none; padding-left: 0; }
        .changelog-list li { padding: 6px 0 6px 20px; color: #495057; font-size: 14px; line-height: 1.6; position: relative; }
        .changelog-list li::before { content: '•'; position: absolute; left: 6px; color: #045E8C; font-weight: bold; }
        .modal-footer { margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end; }
        .modal-footer.spread { justify-content: space-between; }
        .modal-footer button { padding: 9px 18px; border: none; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; }
        .modal-footer .btn-primary { background: #045E8C; color: white; }
        .modal-footer .btn-primary:hover { background: #034a6f; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(4,94,140,0.3); }
        .modal-footer .btn-secondary { background: #e9ecef; color: #495057; }
        .modal-footer .btn-secondary:hover { background: #dee2e6; }
        .gear-btn { width: 28px; height: 28px; border: 1px solid #dee2e6; background: white; cursor: pointer; font-size: 16px; transition: all 0.15s; color: #495057; display: flex; align-items: center; justify-content: center; border-radius: 6px; margin-right: 4px; }
        .gear-btn:hover { background: #f8f9fa; border-color: #ced4da; }
        .config-modal { width: 500px; }
        .config-zones { display: flex; flex-direction: column; gap: 20px; margin-top: 15px; }
        .config-zone { background: #f8f9fa; border-radius: 8px; padding: 12px; min-height: 80px; display: flex; flex-direction: column; }
        .config-punctuation-wrapper { display: flex; justify-content: space-between; align-items: center; gap: 10px; width: 100%; }
        .config-punctuation-left { display: flex; gap: 8px; flex-wrap: wrap; }
        .config-punctuation-right { display: flex; gap: 8px; margin-left: auto; }
        .config-zone.punctuation-zone { background: #fff9e6; min-height: 50px; }
        .config-zone-header { font-size: 11px; font-weight: 700; color: #6c757d; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .config-items-container { display: flex; flex-wrap: wrap; gap: 6px; min-height: 40px; }
        .config-item { height: 22px; padding: 0 12px; background: #045E8C; color: white; border: none; border-radius: 100px; cursor: move; font-size: 12px; font-weight: 500; transition: all 0.15s ease; display: inline-flex; align-items: center; justify-content: center; user-select: none; position: relative; }
        .config-item::before { content: ''; position: absolute; top: -8px; bottom: -8px; left: -8px; right: -8px; pointer-events: none; }
        .config-item.static-text-item::before { display: none; }
        .config-item:hover { background: #034a6f; box-shadow: 0 2px 8px rgba(4,94,140,0.3); transform: translateY(-1px); }
        .config-item.punctuation { background: #f59e0b; width: 28px; padding: 0; font-size: 14px; font-weight: 600; }
        .config-item.punctuation:hover { background: #d97706; }
        .config-item.punctuation[data-id="statictext"] { width: auto; padding: 0 12px; }
        .config-item.static-text-item { width: auto; min-width: 60px; padding: 0 8px 0 4px; cursor: default; position: relative; display: inline-flex; align-items: center; gap: 4px; }
        .config-item.static-text-item input { cursor: text !important; pointer-events: auto !important; user-select: text !important; min-width: 3ch; max-width: 40ch; box-sizing: content-box; }
        .static-text-drag-handle { width: 16px; height: 16px; stroke: white; fill: none; cursor: move; flex-shrink: 0; padding: 2px; opacity: 0.7; transition: all 0.2s; }
        .static-text-drag-handle:hover { opacity: 1; transform: scale(1.1); }
        .config-item.dragging { opacity: 0.3; transform: scale(0.95); }
        .config-item.drop-before { margin-left: 40px; transition: margin-left 0.15s ease; }
        .config-item.drop-after { margin-right: 40px; transition: margin-right 0.15s ease; }
        .config-zone.drag-over { background: #e0e7ff; }
        .line-container { margin-bottom: 12px; }
        .line-header { font-size: 10px; color: #6c757d; margin-bottom: 6px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; display: flex; align-items: center; justify-content: space-between; }
        .line-delete-btn { width: 18px; height: 18px; border: 1px solid #dee2e6; background: white; cursor: pointer; font-size: 10px; color: #dc3545; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .line-delete-btn:hover { background: #dc3545; color: white; border-color: #dc3545; }
        .line-items { display: flex; flex-wrap: wrap; gap: 6px; min-height: 32px; padding: 8px; background: white; border-radius: 6px; border: 2px dashed #dee2e6; }
        .add-line-btn { padding: 6px 12px; background: #e9ecef; color: #495057; border: 1px dashed #ced4da; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600; margin-top: 8px; transition: all 0.2s; }
        .add-line-btn:hover { background: #dee2e6; border-color: #adb5bd; }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <img src="https://lirp.cdn-website.com/c21e3793/dms3rep/multi/opt/D3-CondStack-Wht-Lg-Sq-1920w.png" alt="Logo" class="header-logo">
            <h1>Email Signature Builder for ServiceM8</h1>
        </div>
        <div style="display: flex; align-items: center; gap: 15px;">
            <button class="copy-btn" onclick="S.copy()">Copy Template</button>
            <button class="paste-btn" onclick="S.openPasteModal()">Paste Template</button>
            <div class="version" onclick="S.openChangelogModal()">
                <span>v1.44</span>
                <svg class="version-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="8" cy="8" r="6"></circle>
                    <line x1="8" y1="11" x2="8" y2="8"></line>
                    <circle cx="8" cy="5.5" r="0.5" fill="currentColor"></circle>
                </svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="left-panel">
            <div class="controls">
                <div class="controls-left">
                    <button onclick="S.addSpacer()">+ Spacer</button>
                    <button onclick="S.addText()">+ Static Text</button>
                </div>
                <div class="global-controls-wrapper">
                    <div class="global-font-wrapper">
                        <svg class="font-size-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="4 7 4 4 20 4 20 7"></polyline>
                            <line x1="9" y1="20" x2="15" y2="20"></line>
                            <line x1="12" y1="4" x2="12" y2="20"></line>
                        </svg>
                        <select id="globalFontSize" class="global-font-select" onchange="S.updateGlobalFontSize(this.value)">
                            <option value="10">10</option>
                            <option value="11">11</option>
                            <option value="12">12</option>
                            <option value="13">13</option>
                            <option value="14" selected>14</option>
                            <option value="16">16</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="22">22</option>
                            <option value="24">24</option>
                        </select>
                    </div>
                    <label>
                        <svg class="spacing-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="3" y1="8" x2="16" y2="8"></line>
                            <line x1="3" y1="16" x2="16" y2="16"></line>
                            <polyline points="19 11 19 8 19 5" stroke-width="1.5"></polyline>
                            <polyline points="19 13 19 16 19 19" stroke-width="1.5"></polyline>
                            <line x1="17" y1="12" x2="21" y2="12" stroke-width="1.5"></line>
                        </svg>
                        <span class="spacing-wrapper"><input type="number" id="spacing" value="10" min="0"></span>
                    </label>
                </div>
            </div>
            <div class="items-container">
                <div class="zone" id="active"><div class="zone-header">Active Items</div></div>
                <div class="zone" id="inactive"><div class="zone-header">Inactive Items</div></div>
            </div>
        </div>
        <div class="right-panel">
            <div class="preview-container">
                <div class="preview-mode-toggle">
                    <div class="mode-btn-group">
                        <button class="mode-btn active" onclick="S.setPreviewMode('code')">Code</button>
                        <button class="mode-btn" onclick="S.setPreviewMode('sample')">Sample</button>
                    </div>
                </div>
                <div class="preview-wrapper">
                    <div class="email-placeholder">
                        <p>Hey Jim,</p>
                        <p>So I was thinking about the quarterly report and I have to say - we are CRUSHING it. Like Michael Jordan in the '90s. Speaking of which, we should definitely celebrate with a party. Maybe Pizza by Alfredo? Wait, no - Alfredo's Pizza Cafe. There's a big difference. Anyway, let's sync up about the client meeting. I have some really "great" ideas and new jokes to run by you!</p>
                    </div>
                    <div class="preview" id="preview"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="prefixModal">
        <div class="modal-content">
            <div class="modal-header" id="prefixModalTitle">Set Prefix</div>
            <div class="modal-body">
                <input type="text" id="prefixInput" placeholder="Enter prefix text...">
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="S.closePrefix()">Cancel</button>
                <button class="btn-primary" onclick="S.savePrefix()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="configModal">
        <div class="modal-content config-modal">
            <div class="modal-header" id="configModalTitle">Configure Field</div>
            <div class="modal-body">
                <div class="config-zones">
                    <div class="config-zone">
                        <div class="config-zone-header">Active Elements</div>
                        <div id="configActive"></div>
                    </div>
                    <div class="config-zone">
                        <div class="config-zone-header">Available Elements</div>
                        <div class="config-items-container" id="configInactive"></div>
                    </div>
                    <div class="config-zone punctuation-zone">
                        <div class="config-zone-header">Punctuation</div>
                        <div class="config-items-container" id="configPunctuation"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="S.closeConfig()">Cancel</button>
                <button class="btn-primary" onclick="S.saveConfig()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="fontSizeModal">
        <div class="modal-content">
            <div class="modal-header">Font Size Setting</div>
            <div class="modal-body">
                <p style="margin: 0; color: #495057; line-height: 1.5;">This size matches the global font size. Should this item follow the global setting (auto-update when global changes) or remain fixed at this size?</p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="fontSizeModalCallback(false); document.getElementById('fontSizeModal').classList.remove('show');">Stay Fixed</button>
                <button class="btn-primary" onclick="fontSizeModalCallback(true);">Follow Global</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="pasteModal">
        <div class="modal-content paste-modal-content">
            <div class="modal-header">Paste Email Signature</div>
            <div class="modal-body">
                <p style="margin: 0 0 12px 0; color: #6c757d; font-size: 13px;">Paste your current email signature content from ServiceM8. The builder will parse the merge fields and formatting to reconstruct your signature.</p>
                <textarea id="pasteInput" placeholder="Paste your ServiceM8 email signature content here..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="S.closePasteModal()">Cancel</button>
                <button class="btn-primary" onclick="S.pasteTemplate()">Import</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="changelogModal" onclick="if(event.target.id==='changelogModal') S.closeChangelogModal()">
        <div class="modal-content changelog-modal-content">
            <div class="changelog-header">📋 Changelog</div>
            <div class="modal-body">
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.44 - October 3, 2025</div>
                    <ul class="changelog-list">
                        <li>Enhanced Paste Template button with visual feedback - changes to "Pasted!" with darker blue background</li>
                        <li>Button maintains its blue theme color instead of switching to green for consistency</li>
                        <li>Smoothly fades back to "Paste Template" after 1.5 seconds</li>
                        <li>Removed success alert dialog in favor of inline button feedback</li>
                        <li>Fixed spacer background striping issue when copying templates</li>
                        <li>Added explicit background:transparent to all spacer elements and hr lines</li>
                        <li>Fixed font size dropdown color indicator after template import</li>
                        <li>Items using global font size now correctly show grey dropdown (not blue)</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.41 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Added support for {calculation.current_user_fullname} field in paste template</li>
                        <li>Automatically converts fullname field to standard Staff Name (First + Last) configuration</li>
                        <li>Ensures consistent Staff Name structure across different import sources</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.40 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Fixed paste template parser - smart spacer detection (only creates spacers for 2+ consecutive empty lines)</li>
                        <li>Fixed Company Address detection - address-specific location fields only (not phone/fax/mobile)</li>
                        <li>Parser skips empty lines when looking for address continuation lines</li>
                        <li>All location field lines (including city/state/zip) are now grouped into single Company Address item</li>
                        <li>Eliminated duplicate items and excessive spacers when pasting default templates</li>
                        <li>Fixed Company Address parser - now captures trailing text after last field on line</li>
                        <li>Correctly imports lines like "{location.line1}, Suite 123" with static text after field</li>
                        <li>Single space separators are now skipped (fields have natural spacing)</li>
                        <li>Eliminates double spacing when importing Staff Name and Company Address</li>
                        <li>Fixed Company Address configuration modal - can now drag address fields from inactive to active</li>
                        <li>Allows adding Country, Address Line 2, Address Line 3 to active address configuration</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.35 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Fixed Copy Template button getting stuck when clicked multiple times rapidly</li>
                        <li>Added timeout tracking to clear previous timer when button is clicked again</li>
                        <li>Each click now properly resets the 1.5 second countdown to fade back</li>
                        <li>Fixed Copy Template button size - maintains consistent width when text changes between states</li>
                        <li>Enhanced Copy Template button with visual feedback - changes to "Copied!" with green background</li>
                        <li>Fixed background striping issue when copying templates via Copy Template button</li>
                        <li>Ensures copied HTML has clean, transparent backgrounds without styling artifacts</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.31 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Updated paste template parser to properly detect and import static text punctuation</li>
                        <li>Parser now distinguishes between regular punctuation (commas, spaces) and static text (words)</li>
                        <li>Static text in Staff Name separator (e.g., "Inc.", "Jr.") is correctly imported with isStaticText flag</li>
                        <li>Static text in Company Address (between fields) is correctly imported with surrounding spaces</li>
                        <li>Ensures pasted templates with static text maintain full editability and drag handle functionality</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.30 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Company Logo simplified: no style options available (bold, italic, underline, color)</li>
                        <li>Company Logo font size always matches global font size setting</li>
                        <li>Company Logo prefix button disabled and greyed out for layout consistency</li>
                        <li>Company Logo behavior enforced in both UI controls and output rendering</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.28 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Added Static Text punctuation feature for custom text in address lines (Staff Name & Company Address)</li>
                        <li>Static Text objects appear in punctuation section, positioned on the right side</li>
                        <li>Drag handle (three horizontal lines) for moving static text - only draggable via handle</li>
                        <li>Editable text input with dynamic width (6px per character + 8px padding)</li>
                        <li>Auto-spacing: Static text automatically adds spaces before and after when placed</li>
                        <li>Smart grouping: Static text + adjacent spaces move together when dragging between lines</li>
                        <li>Individual punctuation reordering: Regular punctuation (commas, spaces) can be reordered independently within a line</li>
                        <li>Static text removal: Dragging back to punctuation section removes text and cleans up orphaned spaces</li>
                        <li>Fixed pseudo-element click blocking issue that prevented text editing</li>
                        <li>Fixed deletion bug when dragging punctuation within same consecutive group</li>
                        <li>Fixed changelog modal: footer with Close and Send Request buttons now fixed at bottom (not in scrollable area)</li>
                        <li>Fixed scrollbar spacing: removed gap between scrollbar and right edge of changelog modal</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.05 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Added interactive changelog modal accessible by clicking version badge</li>
                        <li>Version badge now displays info icon (ℹ️) and optimized padding</li>
                        <li>Added "Send Request" button in changelog for feature requests/support</li>
                        <li>Streamlined changelog to single source (modal only, removed code comments)</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.01 - October 2, 2025</div>
                    <ul class="changelog-list">
                        <li>Added horizontal line feature to Spacer objects</li>
                        <li>Added toggle switch to enable/disable line within spacer</li>
                        <li>Line controls: thickness (1-5px), width (XXS-XXL: 40%-100%), and color picker with hex input</li>
                        <li>SVG icons added for height, thickness, and width controls</li>
                        <li>Line is centered within the spacer spacing (e.g., 20px spacer with 2px line = 9px above, 2px line, 9px below)</li>
                        <li>Adjusted control spacing: 2px gap between icons and inputs, 8px gap between control groups</li>
                        <li>Added "px" suffix to spacer height input (shows on idle, fades on hover/focus)</li>
                        <li>Fixed spacer min-height to 48px to prevent visual jump when toggling line</li>
                        <li>Removed standalone "+ Horizontal Line" button from toolbar</li>
                    </ul>
                </div>
                <div class="changelog-version">
                    <div class="changelog-version-title">v1.0 - Initial Release</div>
                    <ul class="changelog-list">
                        <li>Email signature builder with drag-and-drop interface</li>
                        <li>Support for merge fields from ServiceM8</li>
                        <li>Spacer items for vertical spacing</li>
                        <li>Static text items</li>
                        <li>Text formatting: bold, italic, underline, color, font size</li>
                        <li>Prefix support for merge fields</li>
                        <li>Multi-line merge field configuration</li>
                        <li>Preview modes: Code (with merge fields) and Sample (with test data)</li>
                        <li>Copy to clipboard functionality</li>
                        <li>Template import/export via paste modal</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer spread">
                <button class="btn-secondary" onclick="window.location.href='mailto:support@dddesigned.com?subject=ServiceM8%20Email%20Signature%20Builder%20Request'">Send Request</button>
                <button class="btn-primary" onclick="S.closeChangelogModal()">Close</button>
            </div>
        </div>
    </div>
    
    <script>
        let fontSizeModalCallback = null;
        
        const S = {
            items: [],
            nextId: 1,
            globalFontSize: 14,
            currentPrefixId: null,
            previewMode: 'code',
            
            copyButtonTimeout: null,
            pasteButtonTimeout: null,
            
            init() {
                const defaults = [
                    {label:'Staff Name',field:'{staff.first} {staff.last}',active:true,configurable:true,config:{active:[{id:'first',label:'First Name',field:'{staff.first}'},{id:'last',label:'Last Name',field:'{staff.last}'}],inactive:[]}},
                    {label:'Staff Job Title',field:'{staff.job_title}',active:true},
                    {label:'Company Name',field:'{vendor.name}',active:true},
                    {label:'Company Address',field:'{location.line1}',active:true,configurable:true,maxLines:5,config:{active:[[{id:'line1',label:'Address Line 1',field:'{location.line1}'}],[{id:'city',label:'City',field:'{location.city}'},{id:'state',label:'State',field:'{location.state}'},{id:'zip',label:'Post Code',field:'{location.post_code}'}]],inactive:[{id:'line2',label:'Address Line 2',field:'{location.line2}'},{id:'line3',label:'Address Line 3',field:'{location.line3}'},{id:'country',label:'Country',field:'{location.country}'}]}},
                    {label:'Company Phone',field:'{location.phone_1}',active:true},
                    {label:'Company Website',field:'{vendor.website}',active:true},
                    {label:'Company Logo',field:'{company_logo}',active:true},
                    {label:'Company Fax',field:'{location.fax}',active:false},
                    {label:'Company Mobile',field:'{location.mobile}',active:false},
                    {label:'Staff Mobile Phone',field:'{calculation.current_user_mobile}',active:false},
                    {label:'Staff Email',field:'{calculation.current_user_email}',active:false},
                    {label:'Staff Licence Number',field:'{calculation.current_user_customfield_licence_number}',active:false},
                    {label:'BPAY Reference',field:'{company.bpay_customer_ref}',active:false}
                ];
                defaults.forEach(d => {
                    const item = {id:this.nextId++,label:d.label,field:d.field,active:d.active!==undefined?d.active:true,prefix:'',bold:false,italic:false,underline:false,color:'#000000',fontSize:null,type:'merge',configurable:d.configurable||false,config:d.config||null,maxLines:d.maxLines||1};
                    this.items.push(item);
                    // Update field from config if configurable
                    if (item.configurable && item.config) {
                        this.updateFieldFromConfig(item);
                    }
                });
                this.render();
                this.updatePreview();
                document.getElementById('spacing').addEventListener('input', () => this.updatePreview());
            },
            
            render() {
                const active = this.items.filter(i => i.active);
                const inactive = this.items.filter(i => !i.active);
                document.getElementById('active').innerHTML = '<div class="zone-header">Active Items</div>' + active.map(i => this.renderItem(i)).join('');
                document.getElementById('inactive').innerHTML = '<div class="zone-header">Inactive Items</div>' + inactive.map(i => this.renderItem(i)).join('');
                this.attachDragEvents();
            },
            
            renderItem(item) {
                if (item.type === 'spacer') {
                    const hasLine = item.hasLine || false;
                    const thickness = item.lineThickness || 1;
                    const width = item.lineWidth || '100%';
                    // SVG Icons
                    const heightIcon = `<svg class="control-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="2" x2="8" y2="14"></line><polyline points="5 5 8 2 11 5"></polyline><polyline points="5 11 8 14 11 11"></polyline></svg>`;
                    const thicknessIcon = `<svg class="control-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-linecap="round"><line x1="2" y1="4" x2="14" y2="4" stroke-width="1"></line><line x1="2" y1="8" x2="14" y2="8" stroke-width="2"></line><line x1="2" y1="12" x2="14" y2="12" stroke-width="3"></line></svg>`;
                    const widthIcon = `<svg class="control-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="8" x2="14" y2="8"></line><polyline points="5 5 2 8 5 11"></polyline><polyline points="11 5 14 8 11 11"></polyline></svg>`;
                    const lineControls = hasLine ? `<div class="line-controls"><div class="line-control-group">${thicknessIcon}<select class="line-input" onchange="S.updateLineThickness(${item.id}, this.value)"><option value="1" ${thickness===1?'selected':''}>1</option><option value="2" ${thickness===2?'selected':''}>2</option><option value="3" ${thickness===3?'selected':''}>3</option><option value="4" ${thickness===4?'selected':''}>4</option><option value="5" ${thickness===5?'selected':''}>5</option></select></div><div class="line-control-group">${widthIcon}<select class="line-input" onchange="S.updateLineWidth(${item.id}, this.value)"><option value="40%" ${width==='40%'?'selected':''}>XXS</option><option value="50%" ${width==='50%'?'selected':''}>XS</option><option value="60%" ${width==='60%'?'selected':''}>S</option><option value="70%" ${width==='70%'?'selected':''}>M</option><option value="80%" ${width==='80%'?'selected':''}>L</option><option value="90%" ${width==='90%'?'selected':''}>XL</option><option value="100%" ${width==='100%'?'selected':''}>XXL</option></select></div><div class="line-color-bar"><input type="color" class="line-color-input" id="line-color-${item.id}" value="${item.lineColor||'#dee2e6'}" onchange="S.updateLineColor(${item.id}, this.value)"><input type="text" class="line-hex-input" id="line-hex-${item.id}" value="${item.lineColor||'#dee2e6'}" onchange="S.updateLineColorFromHex(${item.id}, this.value)" maxlength="7" placeholder="#000000"></div></div>` : '';
                    return `<div class="item spacer" draggable="true" data-id="${item.id}"><div class="item-left"><span>Spacer</span></div>${item.active ? `<div class="spacer-controls"><div class="spacer-height-group">${heightIcon}<input type="number" class="spacer-input" value="${item.spacing||20}" onchange="S.updateSpacer(${item.id}, this.value)"></div><div class="line-toggle-wrapper"><span class="line-toggle-label">Line</span><button class="line-toggle ${hasLine?'active':''}" onclick="S.toggleLine(${item.id})"></button></div>${lineControls}</div>` : ''}</div>`;
                }
                const isStatic = item.type === 'static';
                const isCompanyLogo = item.field === '{company_logo}';
                const label = isStatic ? `<input type="text" value="${item.field}" onchange="S.updateStaticText(${item.id}, this.value)">` : item.label;
                const prefixBtn = item.active ? (isCompanyLogo ? `<button class="prefix-btn" disabled style="opacity:0.4;cursor:not-allowed;">prefix</button>` : `<button class="prefix-btn ${item.prefix?'active':''}" onclick="S.openPrefix(${item.id})">prefix</button>`) : '';
                const gearBtn = item.active && item.configurable ? `<button class="gear-btn" onclick="S.openConfig(${item.id})">⚙</button>` : '';
                const currentFontSize = isCompanyLogo ? this.globalFontSize : (item.fontSize ?? this.globalFontSize);
                const isManual = item.fontSize !== null;
                const fontSizeClass = isManual ? 'manual' : 'global';
                const fontSizeSelect = item.active && !isCompanyLogo ? `<select class="font-size-select ${fontSizeClass}" onchange="S.handleFontSizeChange(S.getItem(${item.id}), this.value)"><option value="10" ${currentFontSize===10?'selected':''}>10px</option><option value="11" ${currentFontSize===11?'selected':''}>11px</option><option value="12" ${currentFontSize===12?'selected':''}>12px</option><option value="13" ${currentFontSize===13?'selected':''}>13px</option><option value="14" ${currentFontSize===14?'selected':''}>14px</option><option value="16" ${currentFontSize===16?'selected':''}>16px</option><option value="18" ${currentFontSize===18?'selected':''}>18px</option><option value="20" ${currentFontSize===20?'selected':''}>20px</option><option value="22" ${currentFontSize===22?'selected':''}>22px</option><option value="24" ${currentFontSize===24?'selected':''}>24px</option></select>` : '';
                const controls = item.active && !isCompanyLogo ? `<div class="item-controls">${gearBtn}<div class="format-control-bar">${fontSizeSelect}<div class="format-buttons"><button class="format-btn ${item.bold?'active':''}" onclick="S.toggleFormat(${item.id},'bold')">B</button><button class="format-btn ${item.italic?'active':''}" onclick="S.toggleFormat(${item.id},'italic')" style="font-style:italic">I</button><button class="format-btn ${item.underline?'active':''}" onclick="S.toggleFormat(${item.id},'underline')" style="text-decoration:underline">U</button></div><input type="color" class="color-input" id="color-${item.id}" value="${item.color}" onchange="S.updateColor(${item.id}, this.value)"><input type="text" class="hex-input" id="hex-${item.id}" value="${item.color}" onchange="S.updateColorFromHex(${item.id}, this.value)" maxlength="7" placeholder="#000000"></div></div>` : '';
                return `<div class="item ${isStatic?'static-text':''}" draggable="true" data-id="${item.id}"><div class="item-left">${prefixBtn}<span class="item-label">${label}</span></div>${controls}</div>`;
            },
            
            attachDragEvents() {
                document.querySelectorAll('.item').forEach(el => {
                    el.ondragstart = (e) => {
                        this.draggedItem = this.getItem(parseInt(e.currentTarget.dataset.id));
                        e.currentTarget.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    };
                    
                    el.ondragend = (e) => {
                        e.currentTarget.classList.remove('dragging');
                        document.querySelectorAll('.item').forEach(item => item.classList.remove('drag-over'));
                    };
                    
                    el.ondragover = (e) => {
                        e.preventDefault();
                        if (!this.draggedItem) return;
                        const afterElement = this.getDragAfterElement(e.currentTarget.parentElement, e.clientY);
                        const dragging = document.querySelector('.dragging');
                        if (afterElement == null) {
                            e.currentTarget.parentElement.appendChild(dragging);
                        } else {
                            e.currentTarget.parentElement.insertBefore(dragging, afterElement);
                        }
                    };
                    
                    el.ondragenter = (e) => {
                        if (e.target.classList.contains('item') && !e.target.classList.contains('dragging')) {
                            e.target.classList.add('drag-over');
                        }
                    };
                    
                    el.ondragleave = (e) => {
                        if (e.target.classList.contains('item')) {
                            e.target.classList.remove('drag-over');
                        }
                    };
                });
                
                document.querySelectorAll('.zone').forEach(zone => {
                    zone.ondragover = (e) => {
                        e.preventDefault();
                        if (!this.draggedItem) return;
                        const afterElement = this.getDragAfterElement(zone, e.clientY);
                        const dragging = document.querySelector('.dragging');
                        if (afterElement == null) {
                            zone.appendChild(dragging);
                        } else {
                            zone.insertBefore(dragging, afterElement);
                        }
                    };
                    
                    zone.ondrop = (e) => {
                        e.preventDefault();
                        if (!this.draggedItem) return;
                        
                        const newActive = zone.id === 'active';
                        
                        // Check if spacer or static text being moved to inactive - delete it
                        if ((this.draggedItem.type === 'spacer' || this.draggedItem.type === 'static') && !newActive) {
                            this.items = this.items.filter(i => i.id !== this.draggedItem.id);
                            this.render();
                            this.updatePreview();
                            return;
                        }
                        
                        // Get new order from DOM BEFORE updating active status
                        const itemElements = Array.from(zone.querySelectorAll('.item'));
                        const newOrder = itemElements.map(el => parseInt(el.dataset.id)).filter(id => !isNaN(id));
                        
                        // Get items from the other zone (before we change draggedItem's active status)
                        const otherZoneItems = this.items.filter(i => i.active !== newActive && i.id !== this.draggedItem.id);
                        
                        // Now update active status
                        this.draggedItem.active = newActive;
                        
                        // Reorder items array
                        const reorderedItems = [];
                        
                        // Add items in new order
                        newOrder.forEach(id => {
                            const item = this.items.find(i => i.id === id);
                            if (item) reorderedItems.push(item);
                        });
                        
                        // Combine with other zone items
                        this.items = newActive ? [...reorderedItems, ...otherZoneItems] : [...otherZoneItems, ...reorderedItems];
                        
                        this.render();
                        this.updatePreview();
                    };
                });
            },
            
            getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            },
            
            getItem(id) { return this.items.find(i => i.id === id); },
            
            toggleFormat(id, format) { const item = this.getItem(id); if (item) { item[format] = !item[format]; this.render(); this.updatePreview(); } },
            
            updateColor(id, color) {
                const item = this.getItem(id);
                if (item) {
                    item.color = color;
                    const hexInput = document.getElementById(`hex-${id}`);
                    if (hexInput) hexInput.value = color;
                    this.updatePreview();
                }
            },
            
            updateColorFromHex(id, hex) {
                hex = hex.trim();
                if (!hex.startsWith('#')) hex = '#' + hex;
                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                    const item = this.getItem(id);
                    if (item) {
                        item.color = hex;
                        const colorInput = document.getElementById(`color-${id}`);
                        if (colorInput) colorInput.value = hex;
                        this.updatePreview();
                    }
                }
            },
            
            updateSpacer(id, value) { const item = this.getItem(id); if (item) { item.spacing = parseInt(value)||20; this.render(); this.updatePreview(); } },
            toggleLine(id) { const item = this.getItem(id); if (item) { item.hasLine = !item.hasLine; if (item.hasLine && !item.lineThickness) { item.lineThickness = 1; item.lineWidth = '100%'; item.lineColor = '#dee2e6'; } this.render(); this.updatePreview(); } },
            updateLineThickness(id, value) { const item = this.getItem(id); if (item) { item.lineThickness = parseInt(value)||1; this.render(); this.updatePreview(); } },
            updateLineWidth(id, value) { const item = this.getItem(id); if (item) { item.lineWidth = value; this.render(); this.updatePreview(); } },
            updateLineColor(id, value) { 
                const item = this.getItem(id); 
                if (item) { 
                    item.lineColor = value; 
                    const hexInput = document.getElementById(`line-hex-${id}`);
                    if (hexInput) hexInput.value = value;
                    this.updatePreview(); 
                } 
            },
            updateLineColorFromHex(id, hex) {
                hex = hex.trim();
                if (!hex.startsWith('#')) hex = '#' + hex;
                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                    const item = this.getItem(id);
                    if (item) {
                        item.lineColor = hex;
                        const colorInput = document.getElementById(`line-color-${id}`);
                        if (colorInput) colorInput.value = hex;
                        this.updatePreview();
                    }
                }
            },
            updateStaticText(id, value) { const item = this.getItem(id); if (item) { item.field = value; this.updatePreview(); } },
            updateFontSize(id, value) { const item = this.getItem(id); if (item) { item.fontSize = parseInt(value); this.updatePreview(); } },
            
            openPrefix(id) { this.currentPrefixId = id; const item = this.getItem(id); if (item) { document.getElementById('prefixModalTitle').textContent = `Set ${item.label} Prefix`; document.getElementById('prefixInput').value = item.prefix || ''; } document.getElementById('prefixModal').classList.add('show'); },
            closePrefix() { document.getElementById('prefixModal').classList.remove('show'); this.currentPrefixId = null; },
            savePrefix() { const value = document.getElementById('prefixInput').value; if (this.currentPrefixId) { const item = this.getItem(this.currentPrefixId); if (item) { item.prefix = value; this.render(); this.updatePreview(); } } this.closePrefix(); },
            
            openConfig(id) {
                this.currentConfigId = id;
                const item = this.getItem(id);
                if (!item || !item.configurable) return;
                document.getElementById('configModalTitle').textContent = `Configure ${item.label}`;
                this.renderConfigModal(item);
                document.getElementById('configModal').classList.add('show');
            },
            
            closeConfig() {
                document.getElementById('configModal').classList.remove('show');
                this.currentConfigId = null;
                this.tempConfig = null;
            },
            
            renderConfigModal(item) {
                if (!item || !item.config) {
                    console.error('No config found for item:', item);
                    return;
                }
                this.tempConfig = JSON.parse(JSON.stringify(item.config));
                console.log('Rendering config:', this.tempConfig);
                this.refreshConfigModal(item);
            },
            
            refreshConfigModal(item) {
                if (!this.tempConfig) return;
                console.log('Refreshing modal with tempConfig:', this.tempConfig);
                const isMultiLine = item && item.maxLines > 1;
                
                // Render punctuation section (static, always available)
                const punctuations = [
                    {id:'period',label:'.',char:'.'},
                    {id:'comma',label:',',char:','},
                    {id:'space',label:'␣',char:' '},
                    {id:'slash',label:'/',char:'/'},
                    {id:'dash',label:'-',char:'-'}
                ];
                const punctuationLeftHtml = punctuations.map(p => 
                    `<div class="config-item punctuation" draggable="true" data-id="${p.id}" data-punctuation="true">${p.label}</div>`
                ).join('');
                const punctuationRightHtml = `<div class="config-item punctuation" draggable="true" data-id="statictext" data-punctuation="true">Static Text</div>`;
                document.getElementById('configPunctuation').innerHTML = `<div class="config-punctuation-wrapper"><div class="config-punctuation-left">${punctuationLeftHtml}</div><div class="config-punctuation-right">${punctuationRightHtml}</div></div>`;
                
                if (isMultiLine) {
                    let activeHtml = '';
                    this.tempConfig.active.forEach((line, lineIdx) => {
                        activeHtml += `<div class="line-container" data-line="${lineIdx}">`;
                        activeHtml += `<div class="line-header"><span>Line ${lineIdx + 1}</span><button class="line-delete-btn" onclick="S.deleteConfigLine(${lineIdx})" title="Delete Line">🗑️</button></div>`;
                        activeHtml += `<div class="line-items" data-line="${lineIdx}">`;
                        line.forEach(el => {
                            const isPunct = el.isPunctuation ? 'punctuation' : '';
                            const punctAttr = el.isPunctuation ? 'data-punctuation="instance"' : '';
                            const isStaticText = el.isStaticText;
                            const staticClass = isStaticText ? 'static-text-item' : '';
                            const estimatedWidth = Math.max(30, (el.field.length * 6) + 8) + 'px';
                            const content = isStaticText ? `<svg class="static-text-drag-handle" viewBox="0 0 16 16" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="5" x2="13" y2="5"></line><line x1="3" y1="8" x2="13" y2="8"></line><line x1="3" y1="11" x2="13" y2="11"></line></svg><input type="text" value="${el.field}" onchange="S.updateConfigStaticText('${el.id}', this.value)" oninput="S.autoResizeStaticTextInput(this); S.updateConfigStaticText('${el.id}', this.value)" style="border:none;background:transparent;font-size:12px;padding:2px 4px;color:white;width:${estimatedWidth};" placeholder="Enter text">` : el.label;
                            activeHtml += `<div class="config-item ${isPunct} ${staticClass}" draggable="${!isStaticText}" data-line="${lineIdx}" data-id="${el.id}" ${punctAttr}>${content}</div>`;
                        });
                        activeHtml += '</div></div>';
                    });
                    activeHtml += '<button class="add-line-btn" onclick="S.addConfigLine()">+ Add Line</button>';
                    document.getElementById('configActive').innerHTML = activeHtml;
                } else {
                    const itemsHtml = this.tempConfig.active.map(el => {
                        const isPunct = el.isPunctuation ? 'punctuation' : '';
                        const punctAttr = el.isPunctuation ? 'data-punctuation="instance"' : '';
                        const isStaticText = el.isStaticText;
                        const staticClass = isStaticText ? 'static-text-item' : '';
                        const estimatedWidth = isStaticText ? Math.max(30, (el.field.length * 6) + 8) + 'px' : '0';
                        const content = isStaticText ? `<svg class="static-text-drag-handle" viewBox="0 0 16 16" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="5" x2="13" y2="5"></line><line x1="3" y1="8" x2="13" y2="8"></line><line x1="3" y1="11" x2="13" y2="11"></line></svg><input type="text" value="${el.field}" onchange="S.updateConfigStaticText('${el.id}', this.value)" oninput="S.autoResizeStaticTextInput(this); S.updateConfigStaticText('${el.id}', this.value)" style="border:none;background:transparent;font-size:12px;padding:2px 4px;color:white;width:${estimatedWidth};" placeholder="Enter text">` : el.label;
                        return `<div class="config-item ${isPunct} ${staticClass}" draggable="${!isStaticText}" data-id="${el.id}" ${punctAttr}>${content}</div>`;
                    }).join('');
                    document.getElementById('configActive').innerHTML = `<div class="config-items-container" id="configActiveSingle">${itemsHtml}</div>`;
                }
                
                const inactiveHtml = this.tempConfig.inactive.map(el => 
                    `<div class="config-item" draggable="true" data-id="${el.id}">${el.label}</div>`
                ).join('');
                console.log('Inactive items:', this.tempConfig.inactive.length, inactiveHtml);
                document.getElementById('configInactive').innerHTML = inactiveHtml;
                
                this.attachConfigDragEvents();
                this.attachStaticTextDragHandles();
            },
            
            attachStaticTextDragHandles() {
                console.log('Attaching static text drag handles');
                const staticTextItems = document.querySelectorAll('.static-text-item');
                console.log('Found static text items:', staticTextItems.length);
                
                staticTextItems.forEach(item => {
                    const dragHandle = item.querySelector('.static-text-drag-handle');
                    if (dragHandle) {
                        dragHandle.addEventListener('mousedown', (e) => {
                            console.log('Drag handle mousedown - enabling drag');
                            item.setAttribute('draggable', 'true');
                        });
                        
                        // Disable drag after drag ends
                        item.addEventListener('dragend', () => {
                            console.log('Drag ended - disabling drag');
                            item.setAttribute('draggable', 'false');
                        });
                    }
                });
            },
            
            attachConfigDragEvents() {
                this.draggedConfigId = null;
                this.draggedFromLine = null;
                this.draggedIsPunctuation = false;
                this.currentDropTarget = null;
                this.currentDropPosition = null;
                
                const items = document.querySelectorAll('.config-item');
                items.forEach(el => {
                    el.ondragstart = (e) => {
                        this.draggedConfigId = e.currentTarget.dataset.id;
                        this.draggedFromLine = e.currentTarget.dataset.line;
                        // Check if it's a punctuation template OR instance
                        this.draggedIsPunctuation = e.currentTarget.dataset.punctuation === 'true' || e.currentTarget.dataset.punctuation === 'instance';
                        e.currentTarget.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', this.draggedConfigId);
                        console.log('Drag start:', this.draggedConfigId, 'isPunctuation:', this.draggedIsPunctuation);
                    };
                    el.ondragend = (e) => {
                        e.currentTarget.classList.remove('dragging');
                        this.clearDropSpacing();
                        this.draggedConfigId = null;
                        this.draggedFromLine = null;
                        this.draggedIsPunctuation = false;
                    };
                    
                    el.ondragover = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'move';
                        
                        // Find the actual config-item element (might be hovering over pseudo-element)
                        let targetItem = e.target;
                        if (!targetItem.classList.contains('config-item')) {
                            targetItem = e.target.closest('.config-item');
                        }
                        
                        if (targetItem && this.draggedConfigId && this.draggedConfigId !== targetItem.dataset.id && targetItem.classList.contains('config-item')) {
                            this.updateDropSpacing(targetItem, e);
                        }
                    };
                    
                    el.ondrop = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Find the actual config-item element
                        let targetItem = e.target;
                        if (!targetItem.classList.contains('config-item')) {
                            targetItem = e.target.closest('.config-item');
                        }
                        
                        this.clearDropSpacing();
                        
                        if (targetItem && this.draggedConfigId && this.draggedConfigId !== targetItem.dataset.id) {
                            const item = this.getItem(this.currentConfigId);
                            const isMultiLine = item && item.maxLines > 1;
                            const targetId = targetItem.dataset.id;
                            const targetLine = targetItem.dataset.line;
                            const isInstance = this.draggedConfigId.startsWith('punct_');
                            
                            console.log('Dropping on item:', targetId, 'from:', this.draggedConfigId, 'isPunctuation:', this.draggedIsPunctuation, 'isInstance:', isInstance);
                            
                            // If dragging a punctuation TEMPLATE, create new instance
                            // If dragging an INSTANCE, move it like a regular element
                            if (this.draggedIsPunctuation && !isInstance) {
                                // Create new punctuation instance from template
                                if (isMultiLine && targetLine !== undefined) {
                                    this.addPunctuationToLine(this.draggedConfigId, targetId, parseInt(targetLine));
                                } else if (!isMultiLine) {
                                    this.addPunctuationToActive(this.draggedConfigId, targetId);
                                }
                            } else {
                                // Move existing element (regular or punctuation instance)
                                if (isMultiLine && targetLine !== undefined) {
                                    this.reorderConfigInLine(this.draggedConfigId, targetId, parseInt(targetLine));
                                } else if (!isMultiLine) {
                                    this.reorderConfigInActive(this.draggedConfigId, targetId);
                                }
                            }
                            this.refreshConfigModal(item);
                        }
                    };
                });
                
                const inactiveZone = document.getElementById('configInactive');
                if (inactiveZone) {
                    inactiveZone.ondragover = (e) => {
                        // Don't allow punctuation to be dropped in inactive
                        if (this.draggedIsPunctuation) {
                            e.dataTransfer.dropEffect = 'none';
                            return;
                        }
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        inactiveZone.parentElement.classList.add('drag-over');
                    };
                    inactiveZone.ondragleave = (e) => {
                        inactiveZone.parentElement.classList.remove('drag-over');
                    };
                    inactiveZone.ondrop = (e) => {
                        // Don't allow punctuation to be dropped in inactive
                        if (this.draggedIsPunctuation) {
                            return;
                        }
                        e.preventDefault();
                        inactiveZone.parentElement.classList.remove('drag-over');
                        if (this.draggedConfigId) {
                            console.log('Dropping to inactive:', this.draggedConfigId);
                            this.moveConfigToInactive(this.draggedConfigId);
                            const item = this.getItem(this.currentConfigId);
                            this.refreshConfigModal(item);
                        }
                    };
                }
                
                // Handle punctuation zone - dropping punctuation instances here removes them
                const punctuationZone = document.getElementById('configPunctuation');
                if (punctuationZone) {
                    punctuationZone.ondragover = (e) => {
                        // Only accept punctuation instances (not templates) being removed
                        if (!this.draggedConfigId || !this.draggedConfigId.startsWith('punct_')) {
                            return;
                        }
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        punctuationZone.parentElement.style.opacity = '0.5';
                    };
                    punctuationZone.ondragleave = (e) => {
                        punctuationZone.parentElement.style.opacity = '1';
                    };
                    punctuationZone.ondrop = (e) => {
                        e.preventDefault();
                        punctuationZone.parentElement.style.opacity = '1';
                        // If dragging a punctuation instance (not the template), remove it
                        if (this.draggedConfigId && this.draggedConfigId.startsWith('punct_')) {
                            console.log('Removing punctuation instance:', this.draggedConfigId);
                            this.findAndRemoveConfigElement(this.draggedConfigId);
                            const item = this.getItem(this.currentConfigId);
                            this.refreshConfigModal(item);
                        }
                    };
                }
                
                const item = this.getItem(this.currentConfigId);
                const isMultiLine = item && item.maxLines > 1;
                
                if (isMultiLine) {
                    document.querySelectorAll('.line-items').forEach(lineEl => {
                        lineEl.ondragover = (e) => {
                            e.preventDefault();
                            e.dataTransfer.dropEffect = 'move';
                            // Always allow drop on line container
                            if (e.target.classList.contains('line-items') || e.target.closest('.line-items')) {
                                const container = e.target.classList.contains('line-items') ? e.target : e.target.closest('.line-items');
                                container.style.borderColor = '#045E8C';
                            }
                        };
                        lineEl.ondragleave = (e) => {
                            if (e.target === lineEl) {
                                lineEl.style.borderColor = '#dee2e6';
                            }
                        };
                        lineEl.ondrop = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            lineEl.style.borderColor = '#dee2e6';
                            
                            console.log('Drop on line! draggedConfigId:', this.draggedConfigId);
                            
                            if (!this.draggedConfigId) return;
                            
                            // Check if we have a remembered drop position from hovering over an item
                            if (this.currentDropTarget && this.currentDropPosition) {
                                // Use the remembered position - drop in the gap!
                                const targetLine = parseInt(this.currentDropTarget.dataset.line);
                                const targetId = this.currentDropTarget.dataset.id;
                                const isInstance = this.draggedConfigId.startsWith('punct_');
                                
                                if (this.draggedIsPunctuation && !isInstance) {
                                    this.addPunctuationToLine(this.draggedConfigId, targetId, targetLine);
                                } else {
                                    this.reorderConfigInLine(this.draggedConfigId, targetId, targetLine);
                                }
                                this.clearDropSpacing();
                                const item = this.getItem(this.currentConfigId);
                                this.refreshConfigModal(item);
                                return;
                            }
                            
                            // Append to end of line (works for empty or non-empty lines)
                            const container = e.target.classList.contains('line-items') ? e.target : e.target.closest('.line-items');
                            if (container && this.draggedConfigId) {
                                const targetLine = parseInt(container.dataset.line);
                                const isInstance = this.draggedConfigId.startsWith('punct_');
                                console.log('Dropping to line (append):', targetLine, this.draggedConfigId);
                                if (this.draggedIsPunctuation && !isInstance) {
                                    this.addPunctuationToLine(this.draggedConfigId, null, targetLine);
                                } else {
                                    this.moveConfigToLine(this.draggedConfigId, targetLine);
                                }
                                this.clearDropSpacing();
                                const item = this.getItem(this.currentConfigId);
                                this.refreshConfigModal(item);
                            }
                        };
                    });
                } else {
                    const activeZone = document.getElementById('configActiveSingle');
                    if (activeZone) {
                        activeZone.ondragover = (e) => {
                            e.preventDefault();
                            e.dataTransfer.dropEffect = 'move';
                            activeZone.classList.add('drag-over');
                        };
                        activeZone.ondragleave = (e) => {
                            if (e.target === activeZone) {
                                activeZone.classList.remove('drag-over');
                            }
                        };
                        activeZone.ondrop = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            activeZone.classList.remove('drag-over');
                            
                            console.log('Drop on active zone! draggedConfigId:', this.draggedConfigId);
                            
                            if (!this.draggedConfigId) return;
                            
                            // Check if we have a remembered drop position - use it!
                            if (this.currentDropTarget && this.currentDropPosition) {
                                const targetId = this.currentDropTarget.dataset.id;
                                const isInstance = this.draggedConfigId.startsWith('punct_');
                                
                                if (this.draggedIsPunctuation && !isInstance) {
                                    this.addPunctuationToActive(this.draggedConfigId, targetId);
                                } else {
                                    this.reorderConfigInActive(this.draggedConfigId, targetId);
                                }
                                this.clearDropSpacing();
                                const item = this.getItem(this.currentConfigId);
                                this.refreshConfigModal(item);
                                return;
                            }
                            
                            // Append to end of active (works for empty or non-empty containers)
                            const isInstance = this.draggedConfigId.startsWith('punct_');
                            console.log('Dropping to active (append):', this.draggedConfigId);
                            if (this.draggedIsPunctuation && !isInstance) {
                                this.addPunctuationToActive(this.draggedConfigId, null);
                            } else {
                                this.moveConfigToActive(this.draggedConfigId);
                            }
                            this.clearDropSpacing();
                            const item = this.getItem(this.currentConfigId);
                            this.refreshConfigModal(item);
                        };
                    }
                }
            },
            
            moveConfigToInactive(id) {
                console.log('moveConfigToInactive called with:', id);
                let element = this.findAndRemoveConfigElement(id);
                console.log('Found element:', element);
                if (element) {
                    this.tempConfig.inactive.push(element);
                    console.log('New inactive array:', this.tempConfig.inactive);
                }
            },
            
            moveConfigToActive(id) {
                console.log('moveConfigToActive called with:', id);
                let element = this.findAndRemoveConfigElement(id);
                console.log('Found element:', element);
                if (element) {
                    this.tempConfig.active.push(element);
                    console.log('New active array:', this.tempConfig.active);
                }
            },
            
            updateDropSpacing(targetEl, event) {
                if (!targetEl || !targetEl.classList.contains('config-item')) return;
                
                const rect = targetEl.getBoundingClientRect();
                const mouseX = event.clientX;
                const middle = rect.left + rect.width / 2;
                const newPosition = mouseX < middle ? 'before' : 'after';
                
                // Only update if target or position changed
                if (targetEl === this.currentDropTarget && newPosition === this.currentDropPosition) {
                    return;
                }
                
                // Clear previous spacing
                this.clearDropSpacing();
                
                // Apply new spacing
                if (newPosition === 'before') {
                    targetEl.classList.add('drop-before');
                } else {
                    targetEl.classList.add('drop-after');
                }
                
                this.currentDropTarget = targetEl;
                this.currentDropPosition = newPosition;
                this.dropPosition = newPosition;
            },
            
            clearDropSpacing() {
                document.querySelectorAll('.config-item').forEach(el => {
                    el.classList.remove('drop-before', 'drop-after');
                });
                this.currentDropTarget = null;
                this.currentDropPosition = null;
                this.dropPosition = null;
            },
            
            getAutoCompoundPunctuation(punctuationId, array, targetId, dropPosition) {
                // Determine insertion index
                let insertIdx = array.length;
                if (targetId) {
                    insertIdx = array.findIndex(e => e.id === targetId);
                    if (insertIdx !== -1 && dropPosition === 'after') insertIdx++;
                }
                
                const result = [];
                const hasSpaceBefore = insertIdx > 0 && array[insertIdx - 1]?.field === ' ';
                const hasSpaceAfter = insertIdx < array.length && array[insertIdx]?.field === ' ';
                
                // Auto-compound rules
                if (punctuationId === 'period' || punctuationId === 'comma') {
                    // Add punctuation
                    result.push(this.generatePunctuationInstance(punctuationId));
                    // Add space after if not already there
                    if (!hasSpaceAfter) {
                        result.push(this.generatePunctuationInstance('space'));
                    }
                } else if (punctuationId === 'slash' || punctuationId === 'dash' || punctuationId === 'statictext') {
                    // Add space before if not already there
                    if (!hasSpaceBefore) {
                        result.push(this.generatePunctuationInstance('space'));
                    }
                    // Add punctuation
                    result.push(this.generatePunctuationInstance(punctuationId));
                    // Add space after if not already there
                    if (!hasSpaceAfter) {
                        result.push(this.generatePunctuationInstance('space'));
                    }
                } else {
                    // Just space - add as-is
                    result.push(this.generatePunctuationInstance(punctuationId));
                }
                
                return result;
            },
            
            getPunctuationChar(id) {
                const punctuations = {
                    'period': '.',
                    'comma': ',',
                    'space': ' ',
                    'slash': '/',
                    'dash': '-',
                    'statictext': 'Text'
                };
                return punctuations[id] || '';
            },
            
            generatePunctuationInstance(punctuationId) {
                const char = this.getPunctuationChar(punctuationId);
                const isStaticText = punctuationId === 'statictext';
                return {
                    id: 'punct_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    label: char === ' ' ? '␣' : char,
                    field: char,
                    isPunctuation: true,
                    isStaticText: isStaticText
                };
            },
            
            getConsecutivePunctuationGroup(array, startIdx) {
                let start = startIdx;
                let end = startIdx;
                
                // Expand backwards
                while (start > 0 && array[start - 1]?.isPunctuation) {
                    start--;
                }
                
                // Expand forwards
                while (end < array.length - 1 && array[end + 1]?.isPunctuation) {
                    end++;
                }
                
                return { start, end };
            },
            
            addPunctuationToActive(punctuationId, targetId) {
                const punctsToAdd = this.getAutoCompoundPunctuation(punctuationId, this.tempConfig.active, targetId, this.dropPosition);
                
                if (targetId) {
                    let targetIdx = this.tempConfig.active.findIndex(e => e.id === targetId);
                    if (targetIdx !== -1) {
                        if (this.dropPosition === 'after') targetIdx++;
                        // Insert all punctuation instances
                        punctsToAdd.forEach((p, i) => {
                            this.tempConfig.active.splice(targetIdx + i, 0, p);
                        });
                    }
                } else {
                    punctsToAdd.forEach(p => this.tempConfig.active.push(p));
                }
                console.log('Added punctuation to active:', punctsToAdd);
            },
            
            addPunctuationToLine(punctuationId, targetId, targetLine) {
                while (this.tempConfig.active.length <= targetLine) {
                    this.tempConfig.active.push([]);
                }
                
                const punctsToAdd = this.getAutoCompoundPunctuation(punctuationId, this.tempConfig.active[targetLine], targetId, this.dropPosition);
                
                if (targetId) {
                    let targetIdx = this.tempConfig.active[targetLine].findIndex(e => e.id === targetId);
                    if (targetIdx !== -1) {
                        if (this.dropPosition === 'after') targetIdx++;
                        // Insert all punctuation instances
                        punctsToAdd.forEach((p, i) => {
                            this.tempConfig.active[targetLine].splice(targetIdx + i, 0, p);
                        });
                    }
                } else {
                    punctsToAdd.forEach(p => this.tempConfig.active[targetLine].push(p));
                }
                console.log('Added punctuation to line:', targetLine, punctsToAdd);
            },
            
            reorderConfigInActive(draggedId, targetId) {
                console.log('Reordering in active:', draggedId, this.dropPosition, targetId);
                
                // Find consecutive punctuation group if dragging punctuation
                const draggedIdx = this.tempConfig.active.findIndex(e => e.id === draggedId);
                let elementsToMove = [];
                
                if (draggedIdx !== -1 && this.tempConfig.active[draggedIdx].isPunctuation) {
                    // Find all consecutive punctuation
                    const group = this.getConsecutivePunctuationGroup(this.tempConfig.active, draggedIdx);
                    // Remove all from array (in reverse to maintain indices)
                    for (let i = group.end; i >= group.start; i--) {
                        elementsToMove.unshift(this.tempConfig.active.splice(i, 1)[0]);
                    }
                } else {
                    const draggedEl = this.findAndRemoveConfigElement(draggedId);
                    if (!draggedEl) return;
                    elementsToMove = [draggedEl];
                }
                
                // Find new target index (may have shifted after removal)
                let targetIdx = this.tempConfig.active.findIndex(e => e.id === targetId);
                if (targetIdx !== -1) {
                    if (this.dropPosition === 'after') targetIdx++;
                    // Insert all elements
                    elementsToMove.forEach((el, i) => {
                        this.tempConfig.active.splice(targetIdx + i, 0, el);
                    });
                    console.log('New order:', this.tempConfig.active.map(e => e.label));
                }
            },
            
            moveConfigToLine(id, targetLine) {
                console.log('moveConfigToLine called with:', id, 'to line:', targetLine);
                
                // Find which line the element is in and check if it's punctuation
                let elementsToMove = [];
                let sourceLineIdx = null;
                
                for (let i = 0; i < this.tempConfig.active.length; i++) {
                    const idx = this.tempConfig.active[i].findIndex(e => e.id === id);
                    if (idx !== -1) {
                        sourceLineIdx = i;
                        
                        if (this.tempConfig.active[i][idx].isPunctuation) {
                            // Get consecutive punctuation group
                            const group = this.getConsecutivePunctuationGroup(this.tempConfig.active[i], idx);
                            console.log('Moving punctuation group from line', i, 'indices', group.start, 'to', group.end);
                            // Remove all from array (in reverse to maintain indices)
                            for (let j = group.end; j >= group.start; j--) {
                                elementsToMove.unshift(this.tempConfig.active[i].splice(j, 1)[0]);
                            }
                        } else {
                            elementsToMove = [this.tempConfig.active[i].splice(idx, 1)[0]];
                        }
                        break;
                    }
                }
                
                // If not found in active, check inactive
                if (elementsToMove.length === 0) {
                    const inactiveIdx = this.tempConfig.inactive.findIndex(e => e.id === id);
                    if (inactiveIdx !== -1) {
                        console.log('Found in inactive, moving to active line', targetLine);
                        elementsToMove = [this.tempConfig.inactive.splice(inactiveIdx, 1)[0]];
                    }
                }
                
                if (elementsToMove.length === 0) {
                    console.log('No elements found to move');
                    return;
                }
                
                console.log('Moving elements:', elementsToMove.map(e => e.label));
                
                while (this.tempConfig.active.length <= targetLine) {
                    this.tempConfig.active.push([]);
                }
                
                // Add all elements to target line
                elementsToMove.forEach(el => {
                    this.tempConfig.active[targetLine].push(el);
                });
                
                console.log('New active config:', this.tempConfig.active);
            },
            
            reorderConfigInLine(draggedId, targetId, targetLine) {
                console.log('Reordering in line:', targetLine, draggedId, this.dropPosition, targetId);
                
                let elementsToMove = [];
                let sourceLineIdx = null;
                let draggedIdx = -1;
                
                // Find which line the dragged element is in
                for (let i = 0; i < this.tempConfig.active.length; i++) {
                    const idx = this.tempConfig.active[i].findIndex(e => e.id === draggedId);
                    if (idx !== -1) {
                        sourceLineIdx = i;
                        draggedIdx = idx;
                        
                        // If it's static text, move it with adjacent spaces
                        if (this.tempConfig.active[i][idx].isStaticText) {
                            const group = this.getConsecutivePunctuationGroup(this.tempConfig.active[i], idx);
                            console.log('Moving static text with group from', group.start, 'to', group.end);
                            
                            // Remove all from array (in reverse to maintain indices)
                            for (let j = group.end; j >= group.start; j--) {
                                elementsToMove.unshift(this.tempConfig.active[i].splice(j, 1)[0]);
                            }
                        } else {
                            // For regular punctuation, only move the single item
                            elementsToMove = [this.tempConfig.active[i].splice(idx, 1)[0]];
                            console.log('Moving single element:', elementsToMove[0].label);
                        }
                        break;
                    }
                }
                
                if (elementsToMove.length === 0) return;
                
                while (this.tempConfig.active.length <= targetLine) {
                    this.tempConfig.active.push([]);
                }
                
                let targetIdx = this.tempConfig.active[targetLine].findIndex(e => e.id === targetId);
                if (targetIdx !== -1) {
                    if (this.dropPosition === 'after') targetIdx++;
                    // Insert all elements
                    elementsToMove.forEach((el, i) => {
                        this.tempConfig.active[targetLine].splice(targetIdx + i, 0, el);
                    });
                    console.log('New order in line', targetLine, ':', this.tempConfig.active[targetLine].map(e => e.label));
                } else {
                    // Target not found, put elements back
                    elementsToMove.forEach((el) => {
                        this.tempConfig.active[sourceLineIdx].splice(draggedIdx, 0, el);
                    });
                }
            },
            
            findAndRemoveConfigElement(id) {
                console.log('findAndRemoveConfigElement looking for:', id);
                console.log('Current config:', JSON.stringify(this.tempConfig));
                const item = this.getItem(this.currentConfigId);
                const isMultiLine = item && item.maxLines > 1;
                
                if (isMultiLine) {
                    for (let i = 0; i < this.tempConfig.active.length; i++) {
                        const idx = this.tempConfig.active[i].findIndex(e => e.id === id);
                        if (idx !== -1) {
                            const element = this.tempConfig.active[i].splice(idx, 1)[0];
                            console.log('Found in active line', i, ':', element);
                            // DO NOT remove empty lines here - it shifts indices during drag operations
                            // Empty lines will be cleaned up on save
                            return element;
                        }
                    }
                } else {
                    const activeIdx = this.tempConfig.active.findIndex(e => e.id === id);
                    if (activeIdx !== -1) {
                        const element = this.tempConfig.active.splice(activeIdx, 1)[0];
                        console.log('Found in active:', element);
                        return element;
                    }
                }
                
                const inactiveIdx = this.tempConfig.inactive.findIndex(e => e.id === id);
                if (inactiveIdx !== -1) {
                    const element = this.tempConfig.inactive.splice(inactiveIdx, 1)[0];
                    console.log('Found in inactive:', element);
                    return element;
                }
                
                console.log('Element not found!');
                return null;
            },
            
            addConfigLine() {
                if (this.tempConfig && this.tempConfig.active) {
                    this.tempConfig.active.push([]);
                    const item = this.getItem(this.currentConfigId);
                    this.refreshConfigModal(item);
                }
            },
            
            deleteConfigLine(lineIdx) {
                if (!this.tempConfig || !this.tempConfig.active) return;
                
                // Move all items from this line to inactive
                const lineItems = this.tempConfig.active[lineIdx] || [];
                lineItems.forEach(item => {
                    this.tempConfig.inactive.push(item);
                });
                
                // Remove the line
                this.tempConfig.active.splice(lineIdx, 1);
                
                // Refresh the modal
                const item = this.getItem(this.currentConfigId);
                this.refreshConfigModal(item);
            },
            
            saveConfig() {
                if (this.currentConfigId && this.tempConfig) {
                    const item = this.getItem(this.currentConfigId);
                    if (item) {
                        item.config = this.tempConfig;
                        this.updateFieldFromConfig(item);
                        this.render();
                        this.updatePreview();
                    }
                }
                this.closeConfig();
            },
            
            updateConfigStaticText(id, value) {
                if (!this.tempConfig) return;
                
                // Search in active (single line or multi-line)
                if (Array.isArray(this.tempConfig.active)) {
                    if (Array.isArray(this.tempConfig.active[0])) {
                        // Multi-line
                        for (let line of this.tempConfig.active) {
                            const el = line.find(e => e.id === id);
                            if (el) {
                                el.field = value;
                                el.label = value;
                                return;
                            }
                        }
                    } else {
                        // Single line
                        const el = this.tempConfig.active.find(e => e.id === id);
                        if (el) {
                            el.field = value;
                            el.label = value;
                        }
                    }
                }
            },
            
            autoResizeStaticTextInput(input) {
                if (!input) return;
                const value = input.value || input.placeholder || '';
                
                // Use a hidden span to measure actual text width
                if (!this.measureSpan) {
                    this.measureSpan = document.createElement('span');
                    this.measureSpan.style.cssText = 'position: absolute; visibility: hidden; white-space: pre; font-size: 12px; font-family: inherit;';
                    document.body.appendChild(this.measureSpan);
                }
                
                this.measureSpan.textContent = value;
                const measuredWidth = this.measureSpan.offsetWidth;
                
                // Add some padding to the width (8px for comfort)
                const finalWidth = Math.max(30, measuredWidth + 8) + 'px';
                input.style.width = finalWidth;
                
                console.log('Resizing input:', value, 'measuredWidth:', measuredWidth, 'finalWidth:', finalWidth);
            },
            
            enableStaticTextEdit(id, event) {
                console.log('enableStaticTextEdit called with id:', id);
                console.log('event.target:', event.target);
                
                event.stopPropagation();
                event.preventDefault();
                
                // Find the parent config-item div
                const icon = event.target.closest('.static-text-edit-icon');
                console.log('Found icon:', icon);
                if (!icon) {
                    console.error('Icon not found');
                    return;
                }
                
                const configItem = icon.closest('.config-item');
                console.log('Found configItem:', configItem);
                if (!configItem) {
                    console.error('Config item not found');
                    return;
                }
                
                // Add editing class to enable input
                configItem.classList.add('editing');
                console.log('Added editing class');
                
                // Find and focus the input
                const input = configItem.querySelector('input[type="text"]');
                console.log('Found input:', input);
                if (input) {
                    input.focus();
                    input.select();
                    console.log('Input focused and selected');
                    
                    // Remove editing class on blur
                    input.addEventListener('blur', function() {
                        configItem.classList.remove('editing');
                        console.log('Removed editing class on blur');
                    }, { once: true });
                } else {
                    console.error('Input not found in config item');
                }
            },
            
            updateFieldFromConfig(item) {
                if (!item.configurable || !item.config) return;
                const isMultiLine = item.maxLines > 1;
                
                if (isMultiLine) {
                    // Clean up empty lines when saving
                    item.config.active = item.config.active.filter(line => line.length > 0);
                    
                    const lines = item.config.active.map(line => {
                        let result = '';
                        line.forEach((el, idx) => {
                            result += el.field;
                            // Smart spacing: add space if current is NOT punctuation AND next is NOT punctuation
                            if (idx < line.length - 1) {
                                const nextEl = line[idx + 1];
                                if (!el.isPunctuation && !nextEl.isPunctuation) {
                                    result += ' ';
                                }
                            }
                        });
                        return result;
                    }).filter(l => l.trim());
                    item.field = lines.join('\n');
                } else {
                    // Smart spacing for single line
                    let result = '';
                    item.config.active.forEach((el, idx) => {
                        result += el.field;
                        // Smart spacing
                        if (idx < item.config.active.length - 1) {
                            const nextEl = item.config.active[idx + 1];
                            if (!el.isPunctuation && !nextEl.isPunctuation) {
                                result += ' ';
                            }
                        }
                    });
                    item.field = result;
                }
            },
            
            addSpacer() { this.items.push({id:this.nextId++,type:'spacer',active:true,spacing:20,hasLine:false}); this.render(); this.updatePreview(); },
            addText() { this.items.push({id:this.nextId++,label:'Click to edit',field:'Click to edit',type:'static',active:true,prefix:'',bold:false,italic:false,underline:false,color:'#000000',fontSize:null}); this.render(); this.updatePreview(); },
            
            getSampleData() {
                return {
                    '{staff.first}': 'Michael',
                    '{staff.last}': 'Scott',
                    '{staff.job_title}': 'Regional Manager',
                    '{vendor.name}': 'Dunder Mifflin Paper Company',
                    '{location.line1}': '1725 Slough Avenue',
                    '{location.line2}': '',
                    '{location.line3}': '',
                    '{location.city}': 'Scranton',
                    '{location.state}': 'PA',
                    '{location.post_code}': '18505',
                    '{location.country}': 'United States',
                    '{location.phone_1}': '(570) 555-0178',
                    '{location.fax}': '(570) 555-0179',
                    '{location.mobile}': '(570) 555-0180',
                    '{vendor.website}': 'www.dundermifflin.com',
                    '{calculation.current_user_mobile}': '(570) 555-0147',
                    '{calculation.current_user_email}': 'mscott@dundermifflin.com',
                    '{calculation.current_user_customfield_licence_number}': 'PA-MGR-001',
                    '{company.bpay_customer_ref}': 'DM-SCR-001',
                    '{company_logo}': '<img src="https://d2t1xqejof9utc.cloudfront.net/screenshots/pics/630b27dcbf83cd18fd64a7a84f25eb96/large.png" alt="Dunder Mifflin" style="max-width:150px;height:auto;">'
                };
            },
            
            setPreviewMode(mode) {
                this.previewMode = mode;
                // Update button states
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                this.updatePreview();
            },
            
            updatePreview() {
                const globalSpacing = document.getElementById('spacing').value;
                const sampleData = this.getSampleData();
                let html = '';
                this.items.filter(i => i.active).forEach(item => {
                    if (item.type === 'spacer') {
                        if (item.hasLine) {
                            const thickness = item.lineThickness || 1;
                            const totalSpace = item.spacing || 20;
                            const spaceAbove = Math.floor((totalSpace - thickness) / 2);
                            const spaceBelow = totalSpace - thickness - spaceAbove;
                            html += `<div style="height:${spaceAbove}px"></div><hr style="border:none;border-top:${thickness}px solid ${item.lineColor||'#dee2e6'};width:${item.lineWidth||'100%'};margin:0;"><div style="height:${spaceBelow}px"></div>`;
                        } else {
                            html += `<div style="height:${item.spacing||20}px"></div>`;
                        }
                        return;
                    }
                    const isCompanyLogo = item.field === '{company_logo}';
                    const fontSize = isCompanyLogo ? this.globalFontSize : (item.fontSize ?? this.globalFontSize);
                    let style = `color:${item.color};margin:${globalSpacing}px 0;font-size:${fontSize}px;`;
                    if (item.bold) style += 'font-weight:bold;';
                    if (item.italic) style += 'font-style:italic;';
                    if (item.underline) style += 'text-decoration:underline;';
                    
                    let displayText = item.field;
                    
                    // If in sample mode, replace merge fields with sample data
                    if (this.previewMode === 'sample') {
                        Object.keys(sampleData).forEach(key => {
                            displayText = displayText.replaceAll(key, sampleData[key]);
                        });
                    }
                    
                    // Handle multi-line fields (split by \n and render each line)
                    const lines = displayText.split('\n').filter(line => line.trim());
                    if (lines.length > 1) {
                        lines.forEach(line => {
                            html += `<p style="${style}">${item.prefix}${line}</p>`;
                        });
                    } else {
                        html += `<p style="${style}">${item.prefix}${displayText}</p>`;
                    }
                });
                document.getElementById('preview').innerHTML = html;
            },
            
            updateGlobalFontSize(size) {
                this.globalFontSize = parseInt(size);
                this.render();
                this.updatePreview();
            },
            
            handleFontSizeChange(item, newSize) {
                newSize = parseInt(newSize);
                if (newSize === this.globalFontSize && item.fontSize !== null) {
                    // Show modal
                    fontSizeModalCallback = (useGlobal) => {
                        if (useGlobal) {
                            item.fontSize = null;
                        } else {
                            item.fontSize = newSize;
                        }
                        this.render();
                        this.updatePreview();
                        document.getElementById('fontSizeModal').classList.remove('show');
                    };
                    document.getElementById('fontSizeModal').classList.add('show');
                } else {
                    item.fontSize = newSize;
                    this.render();
                    this.updatePreview();
                }
            },
            
            copy() {
                // Always copy the code version (with merge fields), not the sample data
                const currentMode = this.previewMode;
                
                // Temporarily generate code version HTML
                const globalSpacing = document.getElementById('spacing').value;
                let html = '';
                this.items.filter(i => i.active).forEach(item => {
                    if (item.type === 'spacer') {
                        if (item.hasLine) {
                            const thickness = item.lineThickness || 1;
                            const totalSpace = item.spacing || 20;
                            const spaceAbove = Math.floor((totalSpace - thickness) / 2);
                            const spaceBelow = totalSpace - thickness - spaceAbove;
                            html += `<div style="height:${spaceAbove}px;background:transparent;"></div><hr style="border:none;border-top:${thickness}px solid ${item.lineColor||'#dee2e6'};width:${item.lineWidth||'100%'};margin:0;background:transparent;"><div style="height:${spaceBelow}px;background:transparent;"></div>`;
                        } else {
                            html += `<div style="height:${item.spacing||20}px;background:transparent;"></div>`;
                        }
                        return;
                    }
                    const isCompanyLogo = item.field === '{company_logo}';
                    const fontSize = isCompanyLogo ? this.globalFontSize : (item.fontSize ?? this.globalFontSize);
                    let style = `color:${item.color};margin:${globalSpacing}px 0;font-size:${fontSize}px;background:transparent;`;
                    if (item.bold) style += 'font-weight:bold;';
                    if (item.italic) style += 'font-style:italic;';
                    if (item.underline) style += 'text-decoration:underline;';
                    
                    // Always use the field code, not sample data
                    const lines = item.field.split('\n').filter(line => line.trim());
                    if (lines.length > 1) {
                        lines.forEach(line => {
                            html += `<p style="${style}">${item.prefix}${line}</p>`;
                        });
                    } else {
                        html += `<p style="${style}">${item.prefix}${item.field}</p>`;
                    }
                });
                
                // Create temporary element to copy from
                const tempEl = document.createElement('div');
                tempEl.innerHTML = html;
                tempEl.style.cssText = 'position:absolute;left:-9999px;background:none;padding:0;margin:0;border:none;';
                
                // Reset all potential inherited styles
                tempEl.style.background = 'transparent';
                tempEl.style.backgroundColor = 'transparent';
                
                document.body.appendChild(tempEl);
                
                const range = document.createRange();
                range.selectNode(tempEl);
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
                document.execCommand('copy');
                
                // Clean up
                document.body.removeChild(tempEl);
                window.getSelection().removeAllRanges();
                
                // Clear any existing timeout to prevent conflicts
                if (this.copyButtonTimeout) {
                    clearTimeout(this.copyButtonTimeout);
                }
                
                // Update button text
                const copyBtn = document.querySelector('.copy-btn');
                copyBtn.textContent = 'Copied!';
                copyBtn.style.background = '#28a745';
                copyBtn.style.transition = '';
                
                // Fade back after 1.5 seconds
                this.copyButtonTimeout = setTimeout(() => {
                    copyBtn.style.transition = 'all 0.5s ease';
                    copyBtn.textContent = 'Copy Template';
                    copyBtn.style.background = '';
                    this.copyButtonTimeout = null;
                }, 1500);
            },
            
            openPasteModal() {
                document.getElementById('pasteInput').value = '';
                document.getElementById('pasteModal').classList.add('show');
            },
            
            closePasteModal() {
                document.getElementById('pasteModal').classList.remove('show');
            },
            
            openChangelogModal() {
                document.getElementById('changelogModal').classList.add('show');
            },
            
            closeChangelogModal() {
                document.getElementById('changelogModal').classList.remove('show');
            },
            
            pasteTemplate() {
                const html = document.getElementById('pasteInput').value;
                if (!html.trim()) {
                    alert('Please paste some content!');
                    return;
                }
                
                try {
                    this.parseAndImport(html);
                    this.closePasteModal();
                    
                    // Clear any existing timeout
                    if (this.pasteButtonTimeout) {
                        clearTimeout(this.pasteButtonTimeout);
                    }
                    
                    // Update button appearance
                    const pasteBtn = document.querySelector('.paste-btn');
                    pasteBtn.textContent = 'Pasted!';
                    pasteBtn.style.background = '#1d4ed8';
                    pasteBtn.style.transition = '';
                    
                    // Reset after delay
                    this.pasteButtonTimeout = setTimeout(() => {
                        pasteBtn.style.transition = 'all 0.5s ease';
                        pasteBtn.textContent = 'Paste Template';
                        pasteBtn.style.background = '';
                        this.pasteButtonTimeout = null;
                    }, 1500);
                } catch (error) {
                    console.error('Parse error:', error);
                    alert('Error parsing template. Please check the format.');
                }
            },
            
            parseAndImport(text) {
                // Split by lines - keep empty lines to detect spacers
                const lines = text.split('\n').map(l => l.trim());
                
                // Track which default fields were found
                const foundFields = new Set();
                const parsedItems = [];
                let tempId = 1;
                const processedLineIndexes = new Set();
                
                // Parse each line
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    if (processedLineIndexes.has(lineIndex)) continue;
                    
                    const line = lines[lineIndex];
                    
                    // Check if line is empty - count consecutive empty lines for smart spacer detection
                    if (line.length === 0) {
                        // Count consecutive empty lines
                        let emptyCount = 1;
                        let nextIdx = lineIndex + 1;
                        while (nextIdx < lines.length && lines[nextIdx].length === 0) {
                            emptyCount++;
                            processedLineIndexes.add(nextIdx);
                            nextIdx++;
                        }
                        
                        // Only create spacer if 2+ consecutive empty lines (intentional spacing)
                        if (emptyCount >= 2) {
                            console.log(`Found ${emptyCount} consecutive empty lines at index ${lineIndex} - creating spacer`);
                            parsedItems.push({
                                id: tempId++,
                                type: 'spacer',
                                active: true,
                                spacing: emptyCount * 10  // 10px per empty line
                            });
                        } else {
                            console.log(`Single empty line at index ${lineIndex} - skipping (normal spacing)`);
                        }
                        continue;
                    }
                    
                    // Debug: show character codes for curly-brace-like characters
                    const braceChars = line.match(/[^a-z0-9\s,\.\-\(\)]/gi) || [];
                    if (braceChars.length > 0) {
                        console.log('  Special chars found:', braceChars.map(c => `${c} (U+${c.charCodeAt(0).toString(16).toUpperCase().padStart(4, '0')})`));
                    }
                    
                    // Match standard curly braces {}, full-width ｛｝, and small ﹛﹜
                    // Include digits (0-9) in field names
                    const mergeFields = line.match(/[\{｛﹛][a-z0-9_\.]+[\}｝﹜]/gi) || [];
                    
                    // Normalize Unicode braces to standard braces
                    const normalizedFields = mergeFields.map(f => 
                        f.replace(/[｛﹛]/g, '{').replace(/[｝﹜]/g, '}')
                    );
                    
                    console.log('Parsing line:', line, 'Fields:', normalizedFields);
                    
                    if (normalizedFields.length > 0) {
                        // Extract prefix (text before first merge field)
                        const firstFieldIndex = line.indexOf(mergeFields[0]);
                        const prefix = firstFieldIndex > 0 ? line.substring(0, firstFieldIndex) : '';
                        console.log('  Prefix:', prefix);
                        
                        // Has merge fields - try to match against defaults
                        const matched = this.matchToDefault(line, normalizedFields, prefix);
                        console.log('  Matched:', matched ? matched.label : 'NONE');
                        
                        if (matched) {
                            // Mark this field as found
                            foundFields.add(matched.field);
                            
                            matched.id = tempId++;
                            matched.active = true;
                            matched.prefix = prefix;
                            
                            // Special handling: If this is Staff Name, parse the separator between first and last
                            if (matched.label === 'Staff Name' && matched.configurable) {
                                console.log('  -> Staff Name found, checking for separator between first and last name');
                                
                                // Find positions of {staff.first} and {staff.last}
                                const firstIndex = line.indexOf('{staff.first}');
                                const lastIndex = line.indexOf('{staff.last}');
                                
                                if (firstIndex !== -1 && lastIndex !== -1 && lastIndex > firstIndex) {
                                    const separator = line.substring(firstIndex + '{staff.first}'.length, lastIndex);
                                    
                                    if (separator && separator !== ' ') {
                                        console.log('    -> Found separator between names:', separator);
                                        
                                        const staffConfig = [];
                                        staffConfig.push({id:'first',label:'First Name',field:'{staff.first}'});
                                        
                                        // Parse separator (skip single space as fields have natural spacing)
                                        let punctIdCounter = 1;
                                        const isPurelyPunctuation = /^[,\.\-\/\\\s]+$/.test(separator);
                                        
                                        if (isPurelyPunctuation) {
                                            for (let char of separator) {
                                                staffConfig.push({
                                                    id: `punct_${punctIdCounter++}`,
                                                    label: char === ' ' ? '␣' : char,
                                                    field: char,
                                                    isPunctuation: true,
                                                    isStaticText: false
                                                });
                                            }
                                        } else {
                                            const trimmed = separator.trim();
                                            const leadingSpaces = separator.match(/^\s*/)[0].length;
                                            const trailingSpaces = separator.match(/\s*$/)[0].length;
                                            
                                            if (leadingSpaces > 0) {
                                                staffConfig.push({
                                                    id: `punct_${punctIdCounter++}`,
                                                    label: '␣',
                                                    field: ' ',
                                                    isPunctuation: true,
                                                    isStaticText: false
                                                });
                                            }
                                            
                                            staffConfig.push({
                                                id: `punct_${punctIdCounter++}`,
                                                label: trimmed,
                                                field: trimmed,
                                                isPunctuation: true,
                                                isStaticText: true
                                            });
                                            
                                            if (trailingSpaces > 0) {
                                                staffConfig.push({
                                                    id: `punct_${punctIdCounter++}`,
                                                    label: '␣',
                                                    field: ' ',
                                                    isPunctuation: true,
                                                    isStaticText: false
                                                });
                                            }
                                        }
                                        
                                        staffConfig.push({id:'last',label:'Last Name',field:'{staff.last}'});
                                        
                                        matched.config.active = staffConfig;
                                        console.log('    -> Updated Staff Name config:', matched.config);
                                    }
                                }
                            }
                            
                            // Special handling: If this is Company Address, look ahead for more location fields
                            if (matched.label === 'Company Address' && matched.configurable) {
                                console.log('  -> Company Address found, checking next lines for additional location fields');
                                const allAddressLines = [];
                                
                                // First, process the CURRENT line if it has location fields
                                const currentFields = mergeFields.map(f => 
                                    f.replace(/[｛﹛]/g, '{').replace(/[｝﹜]/g, '}')
                                );
                                
                                // Only include ADDRESS location fields (not phone/fax/mobile)
                                const addressFields = ['line1', 'line2', 'line3', 'city', 'state', 'post_code', 'country'];
                                const currentLocationFields = currentFields.filter(f => {
                                    const match = f.match(/\{location\.(\w+)\}/);
                                    return match && addressFields.includes(match[1]);
                                });
                                
                                if (currentLocationFields.length > 0) {
                                    console.log('    -> Current line has location fields:', line);
                                    // Parse separators in current line
                                    const fieldsWithSeparators = [];
                                    let currentPos = 0;
                                    let lastAddressFieldEnd = 0;
                                    
                                    for (let i = 0; i < mergeFields.length; i++) {
                                        const field = currentFields[i];
                                        // Skip non-address location fields
                                        const match = field.match(/\{location\.(\w+)\}/);
                                        if (!match || !addressFields.includes(match[1])) continue;
                                        
                                        const fieldStart = line.indexOf(mergeFields[i], currentPos);
                                        const fieldEnd = fieldStart + mergeFields[i].length;
                                        lastAddressFieldEnd = fieldEnd;
                                        
                                        let separator = '';
                                        // Find next address location field for separator
                                        let foundNext = false;
                                        for (let j = i + 1; j < mergeFields.length; j++) {
                                            const nextMatch = currentFields[j].match(/\{location\.(\w+)\}/);
                                            if (nextMatch && addressFields.includes(nextMatch[1])) {
                                                const nextFieldStart = line.indexOf(mergeFields[j], fieldEnd);
                                                separator = line.substring(fieldEnd, nextFieldStart);
                                                foundNext = true;
                                                break;
                                            }
                                        }
                                        
                                        // If this is the last address field and there's trailing text, capture it
                                        if (!foundNext && fieldEnd < line.length) {
                                            separator = line.substring(fieldEnd);
                                        }
                                        
                                        fieldsWithSeparators.push({ field, separator });
                                        currentPos = fieldEnd;
                                    }
                                    
                                    if (fieldsWithSeparators.length > 0) {
                                        allAddressLines.push({ line, fields: currentLocationFields, fieldsWithSeparators });
                                    }
                                }
                                
                                // Look ahead at next lines (skip empty lines)
                                for (let nextIdx = lineIndex + 1; nextIdx < lines.length; nextIdx++) {
                                    const nextLine = lines[nextIdx];
                                    
                                    // Skip empty lines when looking for address continuation
                                    if (nextLine.length === 0) {
                                        console.log('    -> Skipping empty line at index', nextIdx);
                                        continue;
                                    }
                                    
                                    const nextFields = nextLine.match(/[\{｛﹛][a-z0-9_\.]+[\}｝﹜]/gi) || [];
                                    const normalizedNext = nextFields.map(f => 
                                        f.replace(/[｛﹛]/g, '{').replace(/[｝﹜]/g, '}')
                                    );
                                    
                                    // Check if this line has ADDRESS location fields (not phone/fax/mobile)
                                    const addressFields = ['line1', 'line2', 'line3', 'city', 'state', 'post_code', 'country'];
                                    const hasLocationFields = normalizedNext.some(f => {
                                        const match = f.match(/\{location\.(\w+)\}/);
                                        return match && addressFields.includes(match[1]);
                                    });
                                    if (hasLocationFields) {
                                        console.log('    -> Found additional location line:', nextLine);
                                        
                                        // Parse separators between fields and trailing text
                                        const fieldsWithSeparators = [];
                                        let currentPos = 0;
                                        for (let i = 0; i < nextFields.length; i++) {
                                            const field = normalizedNext[i];
                                            const fieldStart = nextLine.indexOf(nextFields[i], currentPos);
                                            const fieldEnd = fieldStart + nextFields[i].length;
                                            
                                            // Get separator (text between this field and next, or trailing text)
                                            let separator = '';
                                            if (i < nextFields.length - 1) {
                                                const nextFieldStart = nextLine.indexOf(nextFields[i + 1], fieldEnd);
                                                separator = nextLine.substring(fieldEnd, nextFieldStart);
                                            } else if (fieldEnd < nextLine.length) {
                                                // Capture trailing text after last field
                                                separator = nextLine.substring(fieldEnd);
                                            }
                                            
                                            fieldsWithSeparators.push({ field, separator });
                                            currentPos = fieldEnd;
                                        }
                                        
                                        allAddressLines.push({ line: nextLine, fields: normalizedNext, fieldsWithSeparators });
                                        processedLineIndexes.add(nextIdx);
                                    } else {
                                        // Stop at first non-location line
                                        break;
                                    }
                                }
                                
                                // Configure the address with found fields
                                if (allAddressLines.length > 0) {
                                    console.log('    -> Configuring address with', allAddressLines.length, 'lines');
                                    
                                    // Build config from ALL address lines (including current)
                                    const newConfigActive = [];
                                    let punctIdCounter = 1;
                                    
                                    allAddressLines.forEach(lineData => {
                                        const lineRow = [];
                                        lineData.fieldsWithSeparators.forEach((fw, idx) => {
                                            const fieldName = fw.field.match(/\{location\.(\w+)\}/)?.[1] || 'field';
                                            // Add the field
                                            lineRow.push({
                                                id: fieldName,
                                                label: fieldName.charAt(0).toUpperCase() + fieldName.slice(1),
                                                field: fw.field
                                            });
                                            
                                            // If there's a separator, add it as punctuation items (skip single space)
                                            if (fw.separator && fw.separator !== ' ') {
                                                // Check if separator is purely punctuation/space or contains text
                                                const isPurelyPunctuation = /^[,\.\-\/\\\s]+$/.test(fw.separator);
                                                
                                                if (isPurelyPunctuation) {
                                                    // Split into individual characters for commas, periods, spaces, etc.
                                                    for (let char of fw.separator) {
                                                        lineRow.push({
                                                            id: `punct_${punctIdCounter++}`,
                                                            label: char === ' ' ? '␣' : char,
                                                            field: char,
                                                            isPunctuation: true,
                                                            isStaticText: false
                                                        });
                                                    }
                                                } else {
                                                    // Contains text - treat as static text with surrounding spaces
                                                    const trimmed = fw.separator.trim();
                                                    const leadingSpaces = fw.separator.match(/^\s*/)[0].length;
                                                    const trailingSpaces = fw.separator.match(/\s*$/)[0].length;
                                                    
                                                    // Add leading space if exists
                                                    if (leadingSpaces > 0) {
                                                        lineRow.push({
                                                            id: `punct_${punctIdCounter++}`,
                                                            label: '␣',
                                                            field: ' ',
                                                            isPunctuation: true,
                                                            isStaticText: false
                                                        });
                                                    }
                                                    
                                                    // Add static text
                                                    lineRow.push({
                                                        id: `punct_${punctIdCounter++}`,
                                                        label: trimmed,
                                                        field: trimmed,
                                                        isPunctuation: true,
                                                        isStaticText: true
                                                    });
                                                    
                                                    // Add trailing space if exists
                                                    if (trailingSpaces > 0) {
                                                        lineRow.push({
                                                            id: `punct_${punctIdCounter++}`,
                                                            label: '␣',
                                                            field: ' ',
                                                            isPunctuation: true,
                                                            isStaticText: false
                                                        });
                                                    }
                                                }
                                            }
                                        });
                                        newConfigActive.push(lineRow);
                                    });
                                    
                                    matched.config.active = newConfigActive;
                                    console.log('    -> Updated config:', matched.config);
                                }
                            }
                            
                            // If item is configurable, update its field from config
                            if (matched.configurable && matched.config) {
                                console.log('    -> Updating field from config');
                                this.updateFieldFromConfig(matched);
                            }
                            
                            console.log('  Creating item:', matched);
                            parsedItems.push(matched);
                        } else {
                            // Unknown merge field - keep the line as-is
                            parsedItems.push({
                                id: tempId++,
                                label: line,
                                field: line,
                                type: 'merge',
                                active: true,
                                prefix: '',
                                bold: false,
                                italic: false,
                                underline: false,
                                color: '#000000',
                                fontSize: null
                            });
                        }
                    } else {
                        // Static text
                        parsedItems.push({
                            id: tempId++,
                            label: line,
                            field: line,
                            type: 'static',
                            active: true,
                            prefix: '',
                            bold: false,
                            italic: false,
                            underline: false,
                            color: '#000000',
                            fontSize: null
                        });
                    }
                }
                
                // Now rebuild items: parsed items (active) + defaults not found (inactive)
                const defaultFields = [
                    {label:'Staff Name',field:'{staff.first} {staff.last}',configurable:true,config:{active:[{id:'first',label:'First Name',field:'{staff.first}'},{id:'last',label:'Last Name',field:'{staff.last}'}],inactive:[]}},
                    {label:'Staff Job Title',field:'{staff.job_title}'},
                    {label:'Company Name',field:'{vendor.name}'},
                    {label:'Company Address',field:'{location.line1}',configurable:true,maxLines:5,config:{active:[[{id:'line1',label:'Address Line 1',field:'{location.line1}'}],[{id:'city',label:'City',field:'{location.city}'},{id:'state',label:'State',field:'{location.state}'},{id:'zip',label:'Post Code',field:'{location.post_code}'}]],inactive:[{id:'line2',label:'Address Line 2',field:'{location.line2}'},{id:'line3',label:'Address Line 3',field:'{location.line3}'},{id:'country',label:'Country',field:'{location.country}'}]}},
                    {label:'Company Phone',field:'{location.phone_1}'},
                    {label:'Company Website',field:'{vendor.website}'},
                    {label:'Company Logo',field:'{company_logo}'},
                    {label:'Company Fax',field:'{location.fax}'},
                    {label:'Company Mobile',field:'{location.mobile}'},
                    {label:'Staff Mobile Phone',field:'{calculation.current_user_mobile}'},
                    {label:'Staff Email',field:'{calculation.current_user_email}'},
                    {label:'Staff Licence Number',field:'{calculation.current_user_customfield_licence_number}'},
                    {label:'BPAY Reference',field:'{company.bpay_customer_ref}'}
                ];
                
                // Add inactive defaults that weren't found
                defaultFields.forEach(def => {
                    if (!foundFields.has(def.field)) {
                        parsedItems.push({
                            id: tempId++,
                            label: def.label,
                            field: def.field,
                            type: 'merge',
                            active: false,
                            configurable: def.configurable || false,
                            config: def.config || null,
                            maxLines: def.maxLines || 1,
                            prefix: '',
                            bold: false,
                            italic: false,
                            underline: false,
                            color: '#000000',
                            fontSize: null
                        });
                    }
                });
                
                this.items = parsedItems;
                this.nextId = tempId;
                console.log('Final items array:', this.items);
                this.render();
                this.updatePreview();
            },
            
            matchToDefault(textContent, mergeFields, prefix) {
                console.log('  matchToDefault called with:', textContent, mergeFields, prefix);
                
                // Check if line contains specific single fields (match by merge field, not whole line)
                const fieldMap = {
                    '{staff.job_title}': { label: 'Staff Job Title', field: '{staff.job_title}' },
                    '{vendor.name}': { label: 'Company Name', field: '{vendor.name}' },
                    '{location.phone_1}': { label: 'Company Phone', field: '{location.phone_1}' },
                    '{vendor.website}': { label: 'Company Website', field: '{vendor.website}' },
                    '{company_logo}': { label: 'Company Logo', field: '{company_logo}' },
                    '{location.line1}': { label: 'Company Address', field: '{location.line1}' },
                    '{location.fax}': { label: 'Company Fax', field: '{location.fax}' },
                    '{location.mobile}': { label: 'Company Mobile', field: '{location.mobile}' },
                    '{calculation.current_user_mobile}': { label: 'Staff Mobile Phone', field: '{calculation.current_user_mobile}' },
                    '{calculation.current_user_email}': { label: 'Staff Email', field: '{calculation.current_user_email}' },
                    '{calculation.current_user_customfield_licence_number}': { label: 'Staff Licence Number', field: '{calculation.current_user_customfield_licence_number}' },
                    '{company.bpay_customer_ref}': { label: 'BPAY Reference', field: '{company.bpay_customer_ref}' }
                };
                
                // Check for Staff Name (compound field or fullname)
                if (mergeFields.includes('{staff.first}') && mergeFields.includes('{staff.last}')) {
                    console.log('  -> Matched Staff Name (first + last)');
                    return {
                        label: 'Staff Name',
                        field: '{staff.first} {staff.last}',
                        type: 'merge',
                        configurable: true,
                        config: {active:[{id:'first',label:'First Name',field:'{staff.first}'},{id:'last',label:'Last Name',field:'{staff.last}'}],inactive:[]},
                        maxLines: 1,
                        prefix: '',
                        bold: false,
                        italic: false,
                        underline: false,
                        color: '#000000',
                        fontSize: null
                    };
                }
                
                // Check for alternative Staff Name field (calculation.current_user_fullname)
                if (mergeFields.includes('{calculation.current_user_fullname}')) {
                    console.log('  -> Matched Staff Name (fullname field)');
                    return {
                        label: 'Staff Name',
                        field: '{staff.first} {staff.last}',
                        type: 'merge',
                        configurable: true,
                        config: {active:[{id:'first',label:'First Name',field:'{staff.first}'},{id:'last',label:'Last Name',field:'{staff.last}'}],inactive:[]},
                        maxLines: 1,
                        prefix: '',
                        bold: false,
                        italic: false,
                        underline: false,
                        color: '#000000',
                        fontSize: null
                    };
                }
                
                // Check if it's a single known field (even with prefix)
                console.log('  Checking single field, mergeFields.length:', mergeFields.length);
                if (mergeFields.length === 1) {
                    const field = mergeFields[0];
                    console.log('  Single field is:', field);
                    console.log('  Field in map?:', !!fieldMap[field]);
                    console.log('  fieldMap[field] value:', fieldMap[field]);
                    if (fieldMap[field]) {
                        console.log('  INSIDE fieldMap[field] block!');
                        // Special handling for Company Address (needs config)
                        if (field === '{location.line1}') {
                            console.log('  -> Matched Company Address (location.line1)');
                            return {
                                label: 'Company Address',
                                field: '{location.line1}',
                                type: 'merge',
                                configurable: true,
                                maxLines: 5,
                                config: {active:[[{id:'line1',label:'Address Line 1',field:'{location.line1}'}],[{id:'city',label:'City',field:'{location.city}'},{id:'state',label:'State',field:'{location.state}'},{id:'zip',label:'Post Code',field:'{location.post_code}'}]],inactive:[{id:'line2',label:'Address Line 2',field:'{location.line2}'},{id:'line3',label:'Address Line 3',field:'{location.line3}'},{id:'country',label:'Country',field:'{location.country}'}]},
                                prefix: '',
                                bold: false,
                                italic: false,
                                underline: false,
                                color: '#000000',
                                fontSize: null
                            };
                        }
                        
                        console.log('  -> Matched field:', fieldMap[field].label);
                        return {
                            label: fieldMap[field].label,
                            field: fieldMap[field].field,
                            type: 'merge',
                            configurable: false,
                            config: null,
                            maxLines: 1,
                            prefix: '',
                            bold: false,
                            italic: false,
                            underline: false,
                            color: '#000000',
                            fontSize: null
                        };
                    } else {
                        console.log('  NOT entering fieldMap[field] block even though it exists!');
                    }
                }
                
                // Check if this line contains ANY ADDRESS location fields - treat as Company Address
                const addressFieldNames = ['line1', 'line2', 'line3', 'city', 'state', 'post_code', 'country'];
                const locationFields = mergeFields.filter(f => {
                    const match = f.match(/\{location\.(\w+)\}/);
                    return match && addressFieldNames.includes(match[1]);
                });
                console.log('  Address location fields found:', locationFields);
                if (locationFields.length > 0) {
                    // Any address location fields should be treated as Company Address
                    console.log('  -> Matched Company Address (contains address location fields)');
                    
                    // Determine the primary field (prefer line1, city, or first found)
                    let primaryField = '{location.line1}';
                    if (locationFields.includes('{location.line1}')) {
                        primaryField = '{location.line1}';
                    } else if (locationFields.includes('{location.city}')) {
                        primaryField = '{location.city}';
                    } else {
                        primaryField = locationFields[0];
                    }
                    
                    return {
                        label: 'Company Address',
                        field: primaryField,
                        type: 'merge',
                        configurable: true,
                        maxLines: 5,
                        config: {active:[[{id:'line1',label:'Address Line 1',field:'{location.line1}'}]],inactive:[{id:'line2',label:'Address Line 2',field:'{location.line2}'},{id:'line3',label:'Address Line 3',field:'{location.line3}'},{id:'city',label:'City',field:'{location.city}'},{id:'state',label:'State',field:'{location.state}'},{id:'zip',label:'Post Code',field:'{location.post_code}'},{id:'country',label:'Country',field:'{location.country}'}]},
                        prefix: '',
                        bold: false,
                        italic: false,
                        underline: false,
                        color: '#000000',
                        fontSize: null
                    };
                }
                
                console.log('  -> Returning null (no match)');
                return null;
            },
            
            rgbToHex(rgb) {
                if (!rgb || rgb.startsWith('#')) return rgb;
                const match = rgb.match(/\d+/g);
                if (!match || match.length < 3) return '#000000';
                return '#' + match.slice(0, 3).map(x => {
                    const hex = parseInt(x).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
        };
        S.init();
    </script>
</body>
</html>
